---
title: JVM - 字节码指令集与解析
date: 2022-01-28 16:11:54
permalink: /java/jvm/bytecode/
categories:
  - Java
  - JVM
tags: 
  - Java
---

[[TOC]]

## 概述

官方文档：`https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html`

- Java 字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行命令
- Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为 **操作码，Opcode**)以及跟随其后的零至多个代表此操作所需参数(称为 **操作数，Operands**)而构成，由于 **Java 虚拟机采用面向操作数栈而不是寄存器的结构**，所以大多数的指令都不包含操作数，只有一个操作码
- 由于限制了 Java 虚拟机操作码的长度为一个字节(即 0 ~ 255)，这意味着指令集的操作码总数不可能超过 256 条
- 熟悉虚拟机的指令对于动态字节码生成、反编译 Class 文件、 Class 文件修补都有着非常重要的价值。因此，阅读字节码作为了解 Java 虚拟机的基础技能，需要熟练掌握常见指令

### 执行模型

如果不考虑异常处理的话，那么 Java 虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解

```java
do {
    自动计算 PC 寄存器的值加 1;
    根据 PC 寄存器的指示位置，从字节码流中取出操作码;
    if(字节码存在操作数) 从字节码流中取出操作数;
    执行操作码所定义的操作;
}while(字节码长度 > 0)
```

### 字节码与数据类型

在 Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。

对于大部分与数据类型相关的字节码指令，**它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务**：

- i 代表对 int 类型的数据操作
- l 代表 long
- s 代表 short
- b 代表 byte
- c 代表 char
- f 代表 float
- d 代表 double

也有一些指令的助记符中 **没有明确地指明操作类型的字母**，如 arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。

还有另一些指令，如无条件跳转指令 goto 则是与 **数据类型无关的**。

大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译器或运行期将 byte 和short 类型的数据带符号扩展(Sign-Extend)为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（Zero-Extend）为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 init 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。

### 指令分类

由于完全介绍和学习这些指令需要花费大量时间，为了让大家能够更快地熟悉和了解这些基本指令，这里将 JVM 中的字节码指令集按用途大致分成 9 类：

- 加载与存储指令
- 算术指令
- 类型转换指令
- 对象的创建与访问指令
- 方法调用与返回指令
- 操作数栈管理指令
- 比较控制指令
- 异常处理指令
- 同步控制指令

在做值相关操作时：

- 一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用等中取得数据，这些数据(可能是值，可能是对象的引用)被压入操作数栈
- 一个指令，也可以从操作数栈中取出一到多个值（pop 多次），完成赋值、加减乘除、方法传参、系统调用等操作

## 加载与存储指令

> 作用

加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递

> 常用指令

- 局部变量压栈指令：将一个局部变量加载到操作数栈：`xload`、`xload_<n>`（其中 x 为 i、l、f、d、a，n 为 0 到 3），`xaload`、`xaload<n>`（其 x 为 i、l、f、d、a、b、c、s，n 为 0 到 3）

- 常量入栈指令：将一个常量加载到操作数栈：`bipush`、`sipush`、`ldc`、`ldc_w`、`ldc2_w`、`aconst_null`、`iconst_m1`、`iconst_<i>`、`iconst_<l>`、`fconst_<f>`、`dconst_<d>`

- 出栈装入局部变量表指令：将一个数值从操作数栈存储到局部变量表：`xstore`、`xstore_<n>`（其中 x 为 i、l、f、d、a，n 为 0 到 3）， `xastore`（其中 x 为 i、l、f、d、a、b、c、s）

- 扩充局部变量表的访问索引的指令：`wide`

上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如 `iload_<n>`）。这些指令助记符实际上代表了一组指令(例如 `iload_<n>` 代表了 `iload_0、iload_1、iload_2` 和 `iload_3` 这几个指令)。这几组指令都是某个带有一个操作数的通用指令（例如 `iload`）的特殊形式，**对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中**。

除此之外，它们的语义与原生的通用指令完全一致（例如 `iload_0` 的语义与操作数为0时的 `iload` 指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，`<n>` 代表非负的整数，`<i>` 代表是 int 类型数据，`<l>` 代表 long 类型，`<f>` 代表 float 类型，`<d>` 代表 double 类型。

操作 byte、char、short 和 boolean 类型数据时，经常用 int 类型的指令来表示。

### 再谈操作数栈与局部变量表

> **操作数栈(Operand Stacks)**

我们知道，Java 字节码是 Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的。

在解释执行过程中，每当为 Java 方法分配栈帧时，Java 虚拟机往往需要开辟一块额外的空间作为 **操作数栈，来存放计算的操作数以及返回结果**。

具体来说便是：执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。

![image-20220128162015352](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128162023.png)

以加法指令 iadd 为例。假设在执行该指令之前，栈顶的两个元素分别为 int 值 1 和 int 值 2，那么 iadd 指令将弹出这两个 int，并将求得的和 int 值为 3 压入栈中。

![image-20220128162059964](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128162101.png)

由于 iadd 指令只消耗栈顶的两个元素，因此，对于离栈顶距离为 2 的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。

> **局部变量表(Local Variables)**

Java 方法栈帧的另外一个重要组成部分则是局部变量区，**字节码程序可以将计算的结果缓存在局部变量区之中**。

实际上，Java 虚拟机将局部变量区 **当成一个数组**，依次存放 this 指针(仅非静态方法)，所传入的参数，以及字节码中的局部变量。

和操作数栈一样，long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。

![image-20220128162326060](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128162327.png)

举例：

```java
public void foo(long l, float f) {
  {
    int i = 0;
  }
  {
    String s = "Hello, World"
  }
}
```

![image-20220128162357637](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128162358.png)

在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

在方法执行时，虚拟机使用局部变量表完成方法的传递。

### 局部变量压栈指令

> 局部变量压栈常用指令集

| xload_n | xload_0 | xload_1 | xload_2 | xload_3 |
| ------- | ------- | ------- | ------- | ------- |
| iload_n | iload_0 | iload_1 | iload_2 | iload_3 |
| lload_n | lload_0 | lload_1 | lload_2 | lload_3 |
| fload_n | fload_0 | fload_1 | fload_2 | fload_3 |
| dload_n | dload_0 | dload_1 | dload_2 | dload_3 |
| aload_n | aload_0 | aload_1 | aload_2 | aload_3 |

> 局部变量压栈指令剖析

局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。

这类指令大体可以分为：

- `xload_<n>`（x 为 i、l、f、d、a，n 为 0 到 3）
- `xload`（x 为 i、l、f、d、a）

说明：在这里，x 的取值表示数据类型。

指令 `xload_n` 表示将第 `n` 个局部变量压入操作数栈，比如 `iload_1`、`fload_0`、`aload_0` 等指令。其中 `aload_n` 表示将一个对象引用压栈。

指令 `xload` 通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了 4 个，比如指令 `iload`、`fload` 等。

代码示例：

```java
public void load(int num, Object obj, long count, boolean flag, short[] arr) {
    System.out.println(num);
    System.out.println(obj);
    System.out.println(count);
    System.out.println(flag);
    System.out.println(arr);
}
```

分析图：

![image-20220128163125850](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128163127.png)



### 常量入栈指令

> 常量入栈常用指令集

| xconst_n | 范围                                                    | xconst_null | xconst_m1 | xconst_0 | xconst_1 | xconst_2 | xconst_3 | xconst_4 | xconst_5 |
| :------: | ------------------------------------------------------- | ----------- | :-------: | :------: | :------: | :------: | :------: | :------: | :------: |
| iconst_n | [-1, 5]                                                 |             | iconst_m1 | iconst_0 | iconst_1 | iconst_2 | iconst_3 | iconst_4 | iconst_5 |
| lconst_n | 0, 1                                                    |             |           | lconst_0 | lconst_1 |          |          |          |          |
| fconst_n | 0, 1, 2                                                 |             |           | fconst_0 | fconst_1 | fconst_2 |          |          |          |
| dconst_n | 0, 1                                                    |             |           | dconst_0 | dconst_1 |          |          |          |          |
| aconst_n | null, String literal, Class literal                     | aconst_null |           |          |          |          |          |          |          |
|  bipush  | 一个字节，2^8^，[-2^7^, 2^7^ - 1]，即[-128, 127]        |             |           |          |          |          |          |          |          |
|  sipush  | 两个字节，2^16^，[-2^15^, 2^15^ - 1]，即[-32768, 32767] |             |           |          |          |          |          |          |          |
|   ldc    | 四个字节，2^32^，[-2^31^, 2^31^ - 1]                    |             |           |          |          |          |          |          |          |
|  ldc_w   | 宽索引                                                  |             |           |          |          |          |          |          |          |
|  ldc2_w  | 宽索引，long 或 double                                  |             |           |          |          |          |          |          |          |

> 常量入栈指令剖析

常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 const 系列、push 系列和 ldc 指令。

**指令 const 系列**：用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：`iconst_<i>`（i 从 -1 到 5）、`lconst_<l>`（1 从 0 到 1）、`fconst_<f>`（f 从 0 到 2）、`dconst_<d>`（d 从 0 到 1）、`aconst_null`。

比如：

- iconst_m1 将 -1 压入操作数栈
- iconst_x（x 为 0 到 5）将 x 压入栈
- lconst_0、lconst_1 分别将长整数 0 和 1 压入栈
- fconst_0、fconst_1、fconst_2 分别将浮点数 0、1、2 压入栈
- dconst_0 和 dconst_1 分别将 double 型 0 和 1 压入栈
- aconst_null 将 null 压入操作数栈

从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 表示整数，l 表示长整型，f 表示浮点数，d 表示双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。

**指令 push 系列**：主要包括 bipush 和 sipush，它们的区别在于接受数据类型的不同，bipush 接收 8 位整数作为参数，sipush 接收 16 位整数，它们都将参数压入栈。

**指令 ldc 系列**：如果以上指令都不能满足需求，那么可以使用万能的 ldc 指令，它可以接收一个 8 位的参数，该参数指向常量池中的 int、float 或者 String 的索引，将指定的内容压入堆栈。

类似的还有 ldc_w，它接收两个 8 位参数，能支持的索引范围大于 ldc。

如果要压入的元素是 long 或者 double 类型的，则使用 ldc2_w 指令，使用方式都是类似的。

代码示例 1：

```java
public void pushConstLdc() {
    int i = -1;
    int a = 5;
    int b = 6;
    int c = 127;
    int d = 128;
    int e = 32767;
    int f = 32768;
}
```

分析图：

![image-20220128164353879](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128164354.png)

代码示例 2：

```java
public void constLdc() {
    int a1 = 1;
    int a2 = 2;
    int b1 = 2;
    int b2 = 3;
    int c1 = 1;
    int c2 = 2;
    Date d = null;
}
```

分析图

![image-20220128164739853](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128164741.png)

总结如下：

<table>
    <tbody>  
        <tr>
            <th>类型</th> 
            <th>常数指令</th> 
            <th>范围</th> 
       </tr>
       <tr>
            <td rowspan="4">int(boolean,byte,char,short)</td>
            <td>iconst</td>
            <td>[-1, 5]</td>
       </tr>	
       <tr>
            <td>bipush</td>
            <td>[-128, 127]</td>
       </tr>
       <tr>
            <td>sipush</td>
            <td>[-32768, 32767]</td>
       </tr> 
       <tr>
            <td>ldc</td>
            <td>any int value</td>
       </tr>
       <tr>
            <td rowspan="2">long</td>
            <td>lconst</td>
            <td>0, 1</td>
       </tr>	
       <tr>
            <td>ldc</td>
            <td>any long value</td>
       </tr>
       <tr>
            <td rowspan="2">float</td>
            <td>fconst</td>
            <td>0, 1, 2</td>
       </tr>	
       <tr>
            <td>ldc</td>
            <td>any float value</td>
       </tr>
       <tr>
            <td rowspan="2">double</td>
            <td>dconst</td>
            <td>0, 1</td>
       </tr>	
       <tr>
            <td>ldc</td>
            <td>any double value</td>
       </tr> 
       <tr>
            <td rowspan="2">reference</td>
            <td>aconst</td>
            <td>null</td>
       </tr>
       <tr>
            <td>ldc</td>
            <td>String literal, Class literal</td>
       </tr>
   </tbody> 
</table>


### 出栈装入局部变量表指令

> 出栈装入局部变量表常用指令集

| xstore_n | xstore_0 | xstore_1 | xstore_2 | xstore_3 |
| :------: | :------: | :------: | :------: | :------: |
| istore_n | istore_0 | istore_1 | istore_2 | istore_3 |
| lstore_n | lstore_0 | lstore_1 | lstore_2 | lstore_3 |
| fstore_n | fstore_0 | fstore_1 | fstore_2 | fstore_3 |
| dstore_n | dstore_0 | dstore_1 | dstore_2 | dstore_3 |
| astore_n | astore_0 | astore_1 | astore_2 | astore_3 |

> 出栈装入局部变量表指令剖析

出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。

这类指令主要以 store 的形式存在，比如 xstore（x 为 i、l、f、d、a）、xstore_n（x 为 i、l、f、d、a，n为 0 至 3）和 pasture（x 为 i、l、f、d、a、b、c、s）。

- 其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它赋值给局部变量 n（n 对应局部变量表的索引）
- 指令 xstore 由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置
- xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定索引赋值。在 iastore 执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组引用，iastore 会弹出这 3 个值，并将值赋给数组中指定索引的位置

一般说来，类似像 store 这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的 istore_1 指令表示将弹出的元素放置在局部变量表第 1 个位置。类似的还有 istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第 0、2、3 个位置。

由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于 3，那么可以使用 istore 指令，外加一个参数，用来表示需要存放的槽位位置。

代码示例：

```java
public void store(int k, double d) {
    int m = k + 2;
    long l = 12;
    String str = "kele";
    float f = 10.0F;
    d = 10;
}
```

分析图：

![image-20220128165742859](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128165743.png)



## 算术指令

> **作用**

算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。

> **分类**

大体上算术指令可以分为两种：对**整型数据**进行运算的指令与对**浮点型类型数据**进行运算的指令。

> **byte、short、char 和 boolean 类型说明**

在每一大类中，都有针对 Java 虚拟机具体数据类型的专用算术指令。但没有直接支持 byte、short、char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理。此外，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。

![image-20220128170720568](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128170721.png)

> **运算时的溢出**

数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实 Java 虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为 0 时会导致虚拟机抛出异常 `ArithmeticException`。

> **运算模式**

向最接近数舍入模式：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。

向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。

> **NaN 值使用**

当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。而且所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。

代码示例：

```java
public void method() {
    int i = 10;
    double j = i / 0.0;
    System.out.println(j); // Infinity
    
    double d1 = 0.0;
    double d2 = d1 / 0.0;
    System.out.println(j); // NaN
}
```

输出结果：

```java
Infinity
NaN
```

### 所有算数指令

<table>
    <tbody>  
        <tr>
            <th colspan="2">算数指令</th> 
            <th>int(boolean,byte,char,short)</th> 
            <th>long</th>
            <th>float</th> 
      		<th>double</th> 
       </tr>
       <tr>
            <td colspan="2">加法指令</td>
            <td>iadd</td>
            <td>ladd</td>
            <td>fadd</td>
            <td>dadd</td>
       </tr>	
       <tr>
            <td colspan="2">减法指令</td>
            <td>isub</td>
            <td>lsub</td>
            <td>fsub</td>
            <td>dsub</td>
       </tr> 
       <tr>
            <td colspan="2">乘法指令</td>
            <td>imul</td>
            <td>lmul</td>
            <td>fmul</td>
            <td>dmul</td>
       </tr> 
       <tr>
            <td colspan="2">除法指令</td>
            <td>idiv</td>
            <td>ldiv</td>
            <td>fdiv</td>
            <td>ddiv</td>
       </tr>
       <tr>
            <td colspan="2">求余指令</td>
            <td>irem</td>
            <td>lrem</td>
            <td>frem</td>
            <td>drem</td>
       </tr>
       <tr>
            <td colspan="2">取反指令</td>
            <td>ineg</td>
            <td>lneg</td>
            <td>fneg</td>
            <td>dneg</td>
       </tr>
       <tr>
            <td colspan="2">自增指令</td>
            <td>iinc</td>
            <td></td>
            <td></td>
            <td></td>
       </tr>
       <tr>
            <td rowspan="4">位运算指令</td>
            <td>按位或指令</td>
            <td>ior</td>
            <td>lor</td>
            <td></td>
            <td></td>
       </tr> 
       <tr>
            <td>按位或指令</td>
            <td>ior</td>
            <td>lor</td>
            <td></td>
            <td></td>
       </tr> 
       <tr>
            <td>按位与指令</td>
            <td>iand</td>
            <td>land</td>
            <td></td>
            <td></td>
       </tr>
       <tr>
            <td>按位异或指令</td>
            <td>ixor</td>
            <td>lxor</td>
            <td></td>
            <td></td>
       </tr> 
       <tr>
            <td colspan="2">比较指令</td>
            <td></td>
            <td>lcmp</td>
            <td>fcmpg / fcmpl</td>
            <td>dcmpg / dcmpl</td>
       </tr> 
   </tbody> 
</table>

所有算术指令包括：

- 加法指令：iadd、ladd、fadd、dadd

- 减法指令：isub、lsub、fsub、dsub

- 乘法指令：imul、lmul、fmul、dmul

- 除法指令：idiv、ldiv、fdiv、ddiv

- 求余指令：irem、lrem、frem、drem（remainder：余数）

- 取反指令：ineg、lneg、fneg、dneg（negation：取反）

- 自增指令：iinc

- 位运算指令，又可分为：

- - 位移指令：ishl、ishr、iushr、lshl、lshr、lushr
    - 按位或指令：ior、lor
    - 按位与指令：iand、land
    - 按位异或指令：ixor、lxor

- 比较指令：dcmpg、dcmlp、fcmpg、fcmpl、lcmp

> 代码示例 1：取反指令

```java
public void method() {
    float i = 10;
    float j = -i;
    i = -j;
}
```

分析图：

![image-20220128171758178](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128171800.png)

> 代码示例 2：加法指令

```java
public void method() {
    float i = 100;
    i = i + 10
}
```

分析图：

![image-20220128172508897](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128172509.png)

> 代码示例 3：自增指令

```java
public void method() {
    float i = 100;
    i += 10;
}
```

分析图：

![image-20220128172438814](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128172439.png)

对比例子 3 可知道，例子 4 的效率略高于例子 3。

> 代码示例 4：加法和乘法指令

```java
public int method() {
    int a = 80;
    int b = 7;
    int c = 10;
    return (a + b) * c;
}
```

分析图：

![image-20220128172643930](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128172644.png)

> 代码示例 5：加法、减法、位运算指令

```java
public int method(int i, int j) {
    return ((i + j - 1) & ~(j - 1));
}
```

分析图：

![image-20220128172818210](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128172821.png)

> 代码示例 6：加法、减法、乘法指令

```java
public static int bar(int i) {
  return ((i + 1) - 2) * 3 / 4;
}
```

字节码指令对应的图示：

![image-20220128173229321](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128173230.png)

> 代码示例 7：加法指令

```java
public void add() {
	byte i = 15;
	int j = 8;
	int k = i + j;
}
```

字节码指令对应的图示：

![image-20220128173425995](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128173427.png)

> 代码示例 8：除法、加法指令

```java
public void method(int i, int j) {
	int x = 500;
	int y = 100;
	int a = x / y;
	int b = 50;
	System.out.println(a + b);
}
```

字节码指令对应的图示在 [JVM - 方法区](/java/jvm/method-area/#方法区使用举例)。

> 代码示例 9：自增指令

```java
public void method(int i, int j) {
	int i = 10;
	int a = i++;
	int j = 20;
	int b = ++j;
}
```

分析图：

![image-20220128174208402](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128174209.png)

可以看出，`i++` 是先将 a 加入局部变量表后再把前面的 i 加 1，而 `++i` 则是先将 j 加 1，再把 b 加入局部变量表。

> 代码示例 10：自增指令

```java
public void method(int i, int j) {
	int i = 10;
	i = i++;
	System.out.println(i);  // 10
}
```

分析图：

![image-20220128175106972](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128175109.png)

### 比较指令的说明

- 比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈

- 比较指令有：dcmpg、dcmpl、fcmpg、fcmpl、lcmp
    - 与前面讲解的指令类似，首字符 d 表示 double 类型，f 表示 float，l 表示 long

- 对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令，以 float 为例，有 fcmpg 和 fcmpl 两个指令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同

- 指令 dcmpl 和 dcmpg 也是类似的，根据其命名可以推测其含义，在此不再赘述

- 指令 lcmp 针对 long 型整数，由于 long 型整数没有 NaN 值，故无需准备两套指令

> 举例
>

指令 fcmpg 和 fcmpl 都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为 v2， 栈顶顺位第2位元素为 v1，若 v1 = v2，则压入 0；若 v1 >  v2 则压入 1；若 v1 < v2 则压入 -1。

两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入 1，而 fcmpl 会压入 -1。

数值类型的数据才可以谈大小，boolean、引用数据类型不能比较大小。

## 类型转换指令

类型转换指令说明：

- 类型转换指令可以将两种不同的数值类型进行相互转换
- 这些转换操作一般用于实现用户代码中的 **显式类型转换操作**，或者用来处理 **字节码指令集中数据类型相关指令** 无法与 **数据类型** 一一对应的问题

### 类型转换指令集

|            | **byte** | **char** | **short** | **int** | **long** | **float** | **double** |
| :--------: | :------: | :------: | :-------: | :-----: | :------: | :-------: | :--------: |
|  **int**   |   i2b    |   i2c    |    i2s    |    ○    |   i2l    |    i2f    |    i2d     |
|  **long**  | l2i i2b  | l2i i2c  |  l2i i2s  |   l2i   |    ○     |    l2f    |    l2d     |
| **float**  | f2i i2b  | f2i i2c  |  f2i i2s  |   f2i   |   f2l    |     ○     |    f2d     |
| **double** | d2i i2b  | d2i i2c  |  d2i i2s  |   d2i   |   d2l    |    d2f    |     ○      |

### 宽化类型转换

**宽化类型转换( Widening Numeric Conversions)**，也称向上类型转换。

> 转换规则

Java 虚拟机直接支持以下数值的宽化类型转换(Widening Numeric Conversion，小范围类型向大范围类型的安全转换)。也就是说，并不需要指令执行，包括：

- 从 int 类型到 long、float 或者 double 类型，对应的指令为：i2l、i2f、i2d

- 从 long 类型到 float、double 类型。对应的指令为：l2f、l2d

- 从 flaot 类型到 double 类型。对应的指令为：f2d

简化为：int --> long --> float --> double

代码示例：

```java
public void upCast1(){
	int i = 10;
    long l = i;
    float f = i;
    double d = i;
    
    float f1 = l;
    double d1 = l;
    double d2 = f1;
}
```

分析图：

![image-20220128175837267](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128175838.png)

> 精度损失问题

宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，**都不会丢失任何信息**，转换前后的值是精确相等的。

从 int、long 类型数值转换到 float，或者 long 类型树脂转换到 double 时，**将可能发生丢失精度**，可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数数值。尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致 Java 虚拟机抛出运行时异常。

> 补充说明

**从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的**，对于 byte 类型转换为 int，虚拟机并没有做实质性的转化处理，知识简单地通过操作数栈交换了两个数据。而 byte 转为 long 时，使用的是 i2l，可以看到在内部 byte 在这里已经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点：

- 一方面可以减少实际的数据类型，如果为 short 和 byte 都准备一套指令，那么指令的数量就会大增，而 **虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过 256 个，为了节省指令资源，将 short 和 byte 当作 int 处理也是情理之中**
- 另一方面，由于局部变量表中的槽位固定为32位，无论是 byte 或者 short 存入局部变量表，都会占用32位空间。从这个角度来说，也没有必要特意区分这几种数据类型

> 代码示例 1

```java
public void upCast2(){
	int i = 123123123;
    float f = i;
    System.out.println(f);
    
    long l = 123123123123L;
    l = 123123123123123123L;
    double d = l;
    System.out.println(d);
}
```

输出的结果可以看到精度发生损失：

```java
1.2312312E8
1.2312312312312312E17
```

> 代码示例 2

```java
public void upCast3(byte b， short s){
	int i = b;
    i = s;
}
```

上面的代码从不会发生宽化类型转换，我们可以从字节码看出，没有 i2b、i2s。

### 窄化类型转换

**窄化类型转换( Narrowing Numeric Conversion)**，也称向下类型转换、强制类型转换。

> 转换规则

Java 虚拟机也直接支持以下窄化类型转换：

- 从 int 类型至 byte、short 或者 char 类型。对应的指令有：i2b、i2c、i2s
- 从 long 类型到 int 类型。对应的指令有：l2i
- 从 float 类型到 int 或者 long 类型。对应的指令有：f2i、f2l
- 从 double 类型到 int、long 或者 float 类型。对应的指令有：d2i、d2l、d2f

代码示例：

```java
public void downCast1(){
	int i = 10;
    byte b = (byte)i;
    short s = (short)i;
    char c = (char)i;
    
    long l = 10L;
    int i1 = (int)l;
    byte b1 = (byte)l;
}
```

分析图：

![image-20220128181827277](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128181828.png)

由字节码分析，我们知道 float 转为 byte 时，先将 float 转为 int，再转为 byte，走了 2 次转换。

double 转为 byte 同理，先转为 int ，再转为 byte。

> 精度损失问题

窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。

尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是 Java 虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。

代码示例：

```java
public void downCast2(){
	int i = 128;
    byte b = (byte)i;
    System.out.println(b); // -128
}
```

输出的到结果发生了精度损失：

```java
-128
```

> 补充说明

当一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）的时候，将遵循以下转换规则：

- 如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0

- 如果浮点值不是无穷大的话，浮点值使用 IEEE754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T（int 或 long）的表示范围之内，那转换结果就是 v。否则，将根据 v 的符号，转换为 T 所能表示的最大或者最小正数

当一个 double 类型窄化转换为 float 类型时，将遵循以下转换规则：

- 通过向最接近数舍入模式舍入一个可以使用 float 类型表示的数字。最后结果根据下面这 3 条规则判断：


- 如果转换结果的绝对值太小而无法使用 float 来表示，将返回 float 类型的正或负零
- 如果转换结果的绝对值太大而无法使用 float 来表示，将返回 float 类型的正或负无穷大
- 对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值

代码示例：

```java
public void downCast3(){
    double d1 = Double.NaN;
    int i = (int)d1;
    System.out.println(d1); // NaN
    System.out.println(i); // 0
    
    double d2 = Double.POSITIVE_INFINTY; // 正无穷大
    long l = (long)d2;
    int j = (int)d2;
    System.out.println(l); // 9223372036854775807
    System.out.println(Long.MAX_VALUE); // 9223372036854775807
    System.out.println(j); // 2147483647
    System.out.println(Integer.MAX_VALUE); // 2147483647
    
    float f1 = (float)d1;
    System.out.println(f1); // Infinity
    
    float f2 = (float)d2;
    System.out.println(f2); // NaN
}
```

输出结果：

```java
NaN
0
9223372036854775807
9223372036854775807
2147483647
2147483647
Infinity
NaN
```

## 对象的创建与访问指令

Java 是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令和类型检查指令。

### 创建指令

| 创建指令       | 含义             |
| :------------- | :--------------- |
| new            | 创建类实例       |
| newarray       | 创建基本类型数组 |
| anewarray      | 创建引用类型数组 |
| multilanewarra | 创建多维数组     |

虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。

> 创建类实例的指令

- 创建类实例的指令：new

-  它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈
   

> 创建数组的指令

创建数组的指令：`newarray`、`anewarray`、`multianewarray`

- newarray：创建基本类型数组
- anewarray：创建引用类型数组
- multianewarray：创建多维数组

上述创建指令可以用于创建对象或者数组，由于对象和数组在 Java 中的广泛使用，这些指令的使用频率也很高。

> 代码示例 1：创建类实例的指令

```java
public void newInstance() {
    Object obj = new Object();
    
    File file = new File("kele");
}
```

分析图：

![image-20220128201241600](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128201243.png)

如图出现重复地址的原因在于 dup 复制指令，多复制一份，用于存到局部变量表，另外一个则用于出栈。

> 代码示例 2：创建数组的指令

```java
public void newArray() {
    int[] intArray = new int[10];
    Object[] objectArray = new Object[10];
    int[][] mintArray = new int[10][10];
    String[][] strArray = new String[10][];
}
```

分析图：

![image-20220128202121270](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128202122.png)

22 的 anewarray 是因为创建的还是一维数组，因为没有给低维赋值长度，所以只是长度为 10 的一维数组。

### 字段访问指令

| 字段访问指令         | 含义                                                   |
| :------------------- | :----------------------------------------------------- |
| getstatic、putstatic | 访问类字段（static字段，或者称为类变量）的指令         |
| getfield、 putfield  | 访问类实例字段（非static字段，或者称为实例变量）的指令 |

对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。

- 访问类字段（static 字段，或者称为类变量）的指令：`getstatic`（入栈）、`putstatic`（出栈）
- 访问类实例字段（非 static 字段，或者称为实例变量）的指令：`getfield`（入栈）、`putfield`（出栈）

> 代码示例 1：getstatic 指令
>

以 getstatic 指令为例，它含有一个操作数，为指向常量池的 Fieldref 索引，它的作用就是获取 Fieldref 指定的对象或者值，并将其压入操作数栈

```java
public void sayHello() {
  System.out.println("Hello");
}
```

对应的字节码指令：

```java
0 getstatic #8 <java/lang/System.out>
3 ldc #9 <Hello>
5 invokevirtual #10 <java/io/PrintStream.println>
8 return
```

图示：

![image-20220128203128185](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128203129.png)

![image-20220128203211116](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128203212.png)

![image-20220128203323615](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128203324.png)

> 代码示例 2：getfield、putfield 指令

```java
public class Test {
    public void setOrderId() {
        Order order = new Order();
        order.id = 1001;
        System.out.println(order.id);

        Order.name = "ORDER";
        System.out.println(order.name);
	}
}
class Order {
    int id;
    static String name;
}
```

分析图：

![image-20220128204052369](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128204053.png)

### 数组操作指令

数组操作指令主要有：xastore 和 xaload 指令。具体为：

- 把一个数组元素加载到操作数栈的指令：`baload`、`caload`、`saload`、`iaload`、`laload`、`faload`、`daload`、`aaload`
- 将一个操作数栈的值存储到数组元素中的指令：`bastore`、`castore`、`sastore`、`iastore`、`lastore`、`fastore`、`dastore`、`aastore`

`xaload` 依旧是入栈。

`xastore` 不是存放到局部变量表，而是存放到数组里。

| 数组类型        | 加载指令 | 存储指令 |
| --------------- | -------- | -------- |
| byte（boolean） | baload   | bastore  |
| char            | caload   | castore  |
| short           | saload   | sastore  |
| long            | iaload   | laload   |
| float           | faload   | fastore  |
| double          | daload   | dastore  |
| reference       | aaload   | aastore  |

取数组长度的指令：`arraylength`。该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈。

说明：

- 指令 xaload 表示将数组的元素压栈，比如 saload、caload 分别表示压入 short 数组和 char 数组。指令 xaload 在执行时，要求操作数中栈顶元素为数组索引 i，栈顶顺位第2个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 a[i] 重新压入堆栈
- xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定索引赋值。在 iastore 执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组引用，iastore 会弹出这 3 个值，并将值赋给数组中指定索引的位置

> 代码示例 1：数组操作指令

```java
public void setArray() {
    int[] intArray = new int[10];
    intArray[3] = 20;
    System.out.println(intArray[1]);
}
```

分析图：

![image-20220128205459761](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128205500.png)

> 代码示例 2：数组长度的指令

```java
public void arrLength(){

    double[] arr = new double[10];
    System.out.println(arr.length);
}
```

分析图：

![image-20220128205736822](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128205738.png)

### 类型检查指令

检查类实例或数组类型的指令：`instanceof`、`checkcast`

- 指令 `checkcast` 用于检查类型强制转换是否可以进行。如果可以进行，那么 `checkcast` 指令不会改变操作数栈，否则它会抛出 `ClassCastException` 异常
- 指令 `instanceof` 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈

| 类型检查指令 | 含义                             |
| ------------ | -------------------------------- |
| instanceof   | 检查类型强制转换是否可以进行     |
| checkcast    | 判断给定对象是否是某一个类的实例 |

> 代码示例：

```java
public String checkCast(Object obj) {
    if (obj instanceof String) {
        return (String) obj;
    } else {
        return null;
    }
}
```

分析图：

![image-20220128210057657](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128210059.png)

## 方法调用与返回指令

### 方法调用指令

方法调用指令：`invokevirtual`、`invokeinterface`、`invokespecial`、`invokestatic`、`invokedynamic`

以下 5 条指令用于方法调用：

- `invokevirtual` 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是 Java 语言中 **最常见的方法分派方式**
- `invokeinterface` 指令用于 **调用接口方法**，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用
- `invokespecial` 指令用于调用一些需要特殊处理的实例方法，包括 **实例初始化方法（构造器）、私有方法和父类方法**。这些方法都是 **静态类型绑定** 的，不会在调用时进行动态派发
- `invokestatic` 指令用于调用命名 **类中的类方法（static 方法）**。这是 **静态绑定** 的
- `invokedynamic` 调用动态绑定的方法，这个是 JDK 1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在 Java 虚拟机内部，而 `invokedynamic` 指令的分派逻辑是由用户所设定的引导方法决定的

| 方法调用指令    | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| invokevirtual   | 调用对象的实例方法                                           |
| invokeinterface | 调用接口方法                                                 |
| invokespecial   | 调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法 |
| invokestatic    | 调用命名类中的类方法（static方法）                           |
| invokedynamic   | 调用动态绑定的方法                                           |

> 代码示例 1：invokespecial

```java
// 方法调用指令：invokespecial：静态分派
public void invoke1(){
    // 情况 1：类实例构造器方法：<init>()
    Date date = new Date();

    Thread t1 = new Thread();
    // 情况 2：父类的方法
    super.toString();
    // 情况 3：私有方法
    methodPrivate();
}

private void methodPrivate(){

}
```

分析图：

![image-20220128211309643](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128211310.png)

> 代码示例 2：invokestatic

```java
// 方法调用指令：invokestatic：静态分派
public void invoke2(){
    methodStatic();
}
public static void methodStatic(){

}
```

![image-20220128211219606](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128211220.png)

> 代码示例 3：invokeinterface

```java
// 方法调用指令：invokeinterface
public void invoke3(){
    Thread t1 = new Thread();
    ((Runnable)t1).run();

    Comparable<Integer> com = null;
    com.compareTo(123);
}
```

分析图：

![image-20220128211712074](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128211713.png)

> 代码示例 4：invokeVirtual

```java
// 方法调用指令：invokeVirtual：动态分派
public void invoke4(){
    System.out.println("hello");

    Thread t1 = null;
    t1.run();
}
```

分析图：

![image-20220128211536609](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128211537.png)

> 代码示例 5：在接口里定义 static 和 default 方法，分别属于什么？

```java
public class InterfaceMethodTest {
    public static void main(String[] args) {
        AA aa = new BB();

        aa.method2();  // 属于 invokeinterface

        AA.method1(); // 属于 invokestatic
    }
}


interface AA{
    public static void method1(){

    }

    public default void method2(){

    }
}

class BB implements AA{

}
```

分析图：

![image-20220128211837507](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128211838.png)

### 方法返回指令

方法调用结束前，需要进行返回。方法返回指令 **根据返回值的类型进行区分**。

- 包括 `ireturn`（当返回值是 boolean、byte、char、short 和 int 类型时使用）、`lreturn`、`freturn`、`dreturn` 和 `areturn`
- 另外还有一条 `return` 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用

| 返回类型                          | 返回指令 |
| --------------------------------- | -------- |
| void                              | return   |
| int（boolean、byte、char、short） | ireturn  |
| long                              | lreturn  |
| float                             | freutrn  |
| double                            | dreturn  |
| reference                         | Return   |

通过 `ireturn` 指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。

如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 `monitorexit` 指令，退出临界区。

最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。

代码示例（指令已经写在代码的注释里）：

```java
public int returnInt(){
    int i = 500;
    return i;  // ireturn
}

public double returnDouble(){
    return 0.0; // dreturn
}

public String returnString(){
    return "hello,world"; // areturn
}

public int[] returnArr(){
    return null; // areturn
}
public float returnFloat(){
    int i = 10;
    return i; // freturn
}

public byte returnByte(){
    return 0; // ireturn
}

public void methodReturn(){
    int i = returnByte(); // return
}
```

## 操作数栈管理指令

如同操作一个普通数据结构中的堆栈那样，JVM 提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。

这类指令包括如下内容：

- 将一个或两个元素从栈顶弹出，并且直接废弃：`pop`、`pop2`
- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：`dup`、`dup2`、`dup_x1`、`dup2_x1`、`dup_x2`、`dup2_x2`
- 将栈最顶端的两个 Slot 数值位置交换：swap。Java 虚拟机没有提供交换两个 64 位数据类型（long、double）数值的指令
- 指令 nop 是一个非常特殊的指令，它的字节码为 0x00。和汇编语言中的 nop 一样，它表示什么都不做，这条指令一般可用于调试、占位等

这些指令属于通用型，对栈的压入或者弹出无需知名数据类型。

说明：

- 不带 _x 的指令是复制栈顶数据并压入栈顶。包括两个指令，`dup` 和 `dup2`，dup 的系数代表要复制的 Slot 个数

  dup 开头的指令用于复制 1 个 Slot 的数据。例如 1 个 int 或 1 个 `reference` 类型数据。

  dup2 开头的指令用于复制 2 个 Slot 的数据。例如 1 个 long，或 2 个 int，或 1 个 int 加 1 个 float 类型数据。

- 带 _x 的指令是复制栈顶数据并插入栈顶以下的某个位置。共有 4 个指令，`dup_x1`、`dup2_x1`、`dup_x2`、`dup2_x2`。对于带 _x 的复制插入指令，只要将指令的 dup 和 x 的系数相加，结果即为需要插入的位置。因此：

  - dup_x1 插入位置：1+1=2，即栈顶 2 个 Slot 下面

  - dup_x2 插入位置：1+2=3，即栈顶 3 个 Slot 下面

  - dup2_x1 插入位置：2+1=3，即栈顶 3 个 Slot 下面

  - dup2_x2 插入位置：2+2=4，即栈顶 4 个 Slot 下面

- pop：将栈顶的 1 个 Slot 数值出栈。例如 1 个 short 类型数值

- pop2：将栈顶的 2 个 Slot 数值出栈。例如 1 个 double 类型数值，或者 2 个 int 类型数值

> 代码示例 1：pop 指令

```java
public void print(){
    Object obj = new Object();
    obj.toString();
}
```

分析图：

![image-20220128213923699](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128213924.png)

看图我们知道，直接调用 `obj.toString` 没有赋值，则产生 pop，踢出栈，如果是上传注释的 `String info = obj.toString`，则不是 pop，而是 `astore_2`。

> 代码示例 2：pop2 指令

```java
public void foo(){
    bar();
}
public long bar(){
    return 0;
}
```

分析图：

![image-20220128214148750](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128214149.png)



> 代码示例 3：pop2 指令

```java
public long nextIndex() {
    return index++;
}

private long index = 0;
```

分析图：

![image-20220128214736649](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128214737.png)

所以最终输出的还是 0，即对应图中第二个操作数栈的 `idnex:0`。

## 控制转移指令

程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为比较指令、条件跳转指令、比较条件跳转指令、多条件分支跳转指令、无条件跳转指令等。

### 比较指令

比较指令的作用是比较占栈顶两个元素的大小，并将比较结果入栈。比较指令有：`dcmpg`（g 比大）、`dcmpl`（l 比小）、`fcmpg`、`fcmpl`、`lcmp`。与前面讲解的指令类似，首字符 d 表示 double 类型，f 表示 float,l 表示 long。

对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令。以 float 为例，有 `fcmpg` 和 `fcmpl` 两个指令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同。

指令 `dcmpl` 和 `dcmpg` 也是类似的，根据其命名可以推测其含义，在此不再赘述。

**数值类型的数据，才可以谈大小；boolean、引用数据类型不能比较大小。**

> 举例

指令 `fcmp` 和 `fcmpl` 都从中弹出两个操作数，并将它们做比较，设栈顶的元素为 v2，顶顺位第 2 位的元素为 v1：若 `v1 = v2`，则压入 0；若 `v1 > v2`，则压入 1；若 `v1 < v2`，则压入 -1。

两个指令的不同之处在于，如果遇到 NaN 值， `fcmpg` 会压入 1,而 `fcmpl` 会压入 -1。

### 条件跳转指令

条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。

条件跳转指令有：`ifeq`、`iflt`、`ifle`、`ifne`、`ifgt`、`ifge`、`ifnull`、`ifnonnull`。这些指令都接收两个字节的操作数，用于计算跳转的位置(16 位符号整数作为当前位置的 offset)。

它们的统一含义为：**弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置**。

具体说明：

| 指令      | 作用                                 |
| --------- | ------------------------------------ |
| ifeq      | 当栈顶 int 类型数值等于 0 时跳转     |
| ifne      | 当栈顶 int 类型数值不等于 0 时跳转   |
| iflt      | 当栈顶 int 类型数值小于 0 时跳转     |
| ifle      | 当栈顶 int 类型数值小于等于 0 时跳转 |
| ifgt      | 当栈顶 int 类型数值大于 0 时跳转     |
| ifge      | 当栈顶 int 类型数值大于等于 0 时跳转 |
| ifnull    | 为 null 时跳转                       |
| ifnonnull | 不为 null 时跳转                     |

注意：

与前面运算规则一致。

- 对于 boolean、byte、char、short 类型的条件分支比较操作，都是使用 int 类型的比较指令完成
- 对于 long、float、double 类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转
- 由于各类型的比较最终都会转为 int 类型的比较操作，所以 Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的

> 代码示例 1：ifeq 指令

因为图片容易丢失，下面的字节码都以代码块形式出现。

```java
public void compare1(){
    int a = 0;
    if(a != 0){
        a = 10;
    }else{
        a = 20;
    }
}
```

字节码：

```java {4}
 0 iconst_0
 1 istore_1
 2 iload_1
 3 ifeq 12 (+9)
 6 bipush 10
 8 istore_1
 9 goto 15 (+6)
12 bipush 20
14 istore_1
15 return
```

可以看出：`ifeq` 不相等后，跳转到 8 行（代码块行数），赋值为 20，然后下一步是执行第 7 行 goto 到 10 行，结束运行。

> 代码示例 2：ifnonnull 指令

```java
public boolean compareNull(String str){
    if(str == null){
        return true;
    }else{
        return false;
    }
}
```

字节码：

```java {2}
0 aload_1
1 ifnonnull 6 (+5)
4 iconst_1
5 ireturn
6 iconst_0
7 ireturn
```

如果 str 为 null，则不跳转，往下走。否则直接跳转到第 6 行（里面的数字）。

> 代码示例 3：ifge 指令

```java
public void compare2() {
    float f1 = 9;
    float f2 = 10;
    System.out.println(f1 < f2); // true
}
```

字节码：

```java {8,9}
 0 ldc #2 <9.0>
 2 fstore_1
 3 ldc #3 <10.0>
 5 fstore_2
 6 getstatic #4 <java/lang/System.out : Ljava/io/PrintStream;>
 9 fload_1
10 fload_2
11 fcmpg
12 ifge 19 (+7)
15 iconst_1
16 goto 20 (+4)
19 iconst_0
20 invokevirtual #5 <java/io/PrintStream.println : (Z)V>
23 return
```

`fcmpg` 比较后得到 -1，并且 `ifge` 比较 -1 小于 0，则不跳转， 10 行（代码块行数）赋值为 1，最后 goto 出去，所以最终输出为 true。

为什么不是 1？

看 13 行代码，因为 PrintStream 类的 (Z)V> 是输出 boolean 类型，1 对应 true。

> 代码示例 4：ifle 指令

```java
public void compare3() {
    int i1 = 10;
    long l1 = 20;
    System.out.println(i1 > l1); // false
}
```

字节码：

```java {10}
 0 bipush 10
 2 istore_1
 3 ldc2_w #6 <20>
 6 lstore_2
 7 getstatic #4 <java/lang/System.out : Ljava/io/PrintStream;>
10 iload_1
11 i2l
12 lload_2
13 lcmp
14 ifle 21 (+7)
17 iconst_1
18 goto 22 (+4)
21 iconst_0
22 invokevirtual #5 <java/io/PrintStream.println : (Z)V>
25 return
```

i1 通过第 7 行的 `i21` 转为 long 类型才能进行比较。

通过 lcmp 指令得出的是 -1，则 ifle 指令判断小于等于 0 跳转到 13 行，得到 0，所以通过 goto 跳出，最终输出 false（0 对应 false）。

> 代码示例 5：ifle 指令

```java
public int compare4(double d) {
    if (d > 50.0) {
        return 1;
    } else {
        return -1;
    }
}
```

字节码：

```java {3,4}
 0 dload_1
 1 ldc2_w #8 <50.0>
 4 dcmpl
 5 ifle 10 (+5)
 8 iconst_1
 9 ireturn
10 iconst_m1
11 ireturn
```

`dcmpl` 判断 d 是否小于 50.0，小于则压入 1，否则 0。

`ifle` 判断压入的值是否小于等于 0，如果是则跳转到第 7 行。得到 -1（m1），反之得到第 5 行的 1。

### 比较条件跳转指令

比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。

这类指令有：`if_icmped`、`if_icmpne`、`if_icmplt`、`if_icmpgt`、`if_icmple`、`if_icmpge`、`if_acmped` 和 `if_acmpne`。

其中指令助记符加上 "if_" 后，以字符 "i" 开头的指令针对 int 型整数操作(也包括 short 和 byte 类型)，以字符 "a" 开头的指令表示对象引用的比较。

具体说明：

| 指令      | 作用                                                |
| --------- | --------------------------------------------------- |
| if_icmpeq | 比较栈顶两 int 型数值大小，当前者等于后者时跳转     |
| if_icmpne | 比较栈顶两 int 型数值大小，当前者不等于后者时跳转   |
| if_icmplt | 比较栈顶两 int 型数值大小，当前者小于后者时跳转     |
| if_icmple | 比较栈顶两 int 型数值大小，当前者小于等于后者时跳转 |
| if_icmpgt | 比较栈顶两 int 型数值大小，当前者大于后者时跳转     |
| if_icmpge | 比较栈顶两 int 型数值大小，当前者大于等于后者时跳转 |
| if_acmpeq | 比较栈顶两引用类型数值，当结果相等时跳转            |
| if_acmpne | 比较栈顶两引用类型数值，当结果不相等时跳转          |

这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。**如果预设条件成立，则执行跳转，否则，继续执行下一条语句**。

> 代码示例 1：if_icmple 指令

```java
public void ifCompare1(){
    int i = 10;
    int j = 20;
    System.out.println(i > j); // false
}
```

字节码：

```java {8}
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
 6 getstatic #4 <java/lang/System.out : Ljava/io/PrintStream;>
 9 iload_1
10 iload_2
11 if_icmple 18 (+7)
14 iconst_1
15 goto 19 (+4)
18 iconst_0
19 invokevirtual #5 <java/io/PrintStream.println : (Z)V>
22 return
```

`if_icmple` 判断 i 小于等于 j 为 true，则跳转第 11 行，得到 0，最后输出 false。

> 代码示例 2：if_icmple 指令

```java
public void ifCompare2() {
    short s1 = 9;
    byte b1 = 10;
    System.out.println(s1 > b1); // false
}
```

字节码：

```java {8}
 0 bipush 9
 2 istore_1
 3 bipush 10
 5 istore_2
 6 getstatic #4 <java/lang/System.out : Ljava/io/PrintStream;>
 9 iload_1
10 iload_2
11 if_icmple 18 (+7)
14 iconst_1
15 goto 19 (+4)
18 iconst_0
19 invokevirtual #5 <java/io/PrintStream.println : (Z)V>
22 return
```

`if_icmple` 判断 s1 小于等于 b1 为 true，则跳转第 11 行，得到 0，最后输出 false。

和代码示例 1 的区别就是 short 和 byte 类型自动转为 int 类型。

> 代码示例 3：if_acmpne、if_acmpeq 指令

```java
public void ifCompare3() {
    Object obj1 = new Object();
    Object obj2 = new Object();
    System.out.println(obj1 == obj2); // false
    System.out.println(obj1 != obj2); // true
}
```

字节码：

```java {12,20}
 0 new #10 <java/lang/Object>
 3 dup
 4 invokespecial #1 <java/lang/Object.<init> : ()V>
 7 astore_1
 8 new #10 <java/lang/Object>
11 dup
12 invokespecial #1 <java/lang/Object.<init> : ()V>
15 astore_2
16 getstatic #4 <java/lang/System.out : Ljava/io/PrintStream;>
19 aload_1
20 aload_2
21 if_acmpne 28 (+7)
24 iconst_1
25 goto 29 (+4)
28 iconst_0
29 invokevirtual #5 <java/io/PrintStream.println : (Z)V>
32 getstatic #4 <java/lang/System.out : Ljava/io/PrintStream;>
35 aload_1
36 aload_2
37 if_acmpeq 44 (+7)
40 iconst_1
41 goto 45 (+4)
44 iconst_0
45 invokevirtual #5 <java/io/PrintStream.println : (Z)V>
48 return
```

`if_acmpne` 指令当结果不相等时跳转 15 行，得到 0，输出 false。

`if_acmpeq` 指令当结果不相等时不跳转，进入 21 行，得到 1，输出 true。 

### 多条件分支跳转

多条件分支跳转指令是专为 switch-case 语句设计的，主要有 `tableswitch` 和 `lookupswitch`。

| 指令名称     | 描述                                |
| ------------ | ----------------------------------- |
| tableswitch  | 用于 switch 条件跳转，case 值连续   |
| lookupswitch | 用于 switch 条件跳转，case 值不连续 |

从助记符上看，两者都是 switch 语句的实现，它们的区别：

- `tableswitch` 要求 **多个条件分支值是连续的**，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，**因此效率比较高**
- `lookupswitch` 内部 **存放着各个离散的 case-offset 对**，每次执行都要搜索全部的 case-offset 对，找到匹配的 case 值，并根据对应的 offset 计算跳转地址，**因此效率较低**

指令 `tableswitch` 的示意图如下图所示。由于 tableswitch 的 case 值是连续的，因此只需要记录最低值和最高值，以及每一项对应的 offset 偏移量，根据给定的 index 值通过简单的计算即可直接定位到 offset。

![image-20220128224602854](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128224604.png)



指令 `lookupswitch` 处理的是离散的 case 值，但是出于效率考虑，将 case-offset 对按照 case 值大小排序，给定 index 时，需要查找与 index 相等的 case，获得其 offset，如果找不到则跳转到 default。指令 lookupswitch 如下图所示：

![image-20220128224620672](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128224621.png)



> 代码示例 1：tableswitch 指令

```java
public void swtich1(int select){
    int num;
    switch(select){
        case 1:
            num = 10;
            break;
        case 2:
            num = 20;
            //break;
        case 3:
            num = 30;
            break;
        default:
            num = 40;
    }
}
```

字节码：

```java {2-6}
 0 iload_1
 1 tableswitch 1 to 3
	1:  28 (+27)
	2:  34 (+33)
	3:  37 (+36)
	default:  43 (+42)
28 bipush 10
30 istore_2
31 goto 46 (+15)
34 bipush 20
36 istore_2
37 bipush 30
39 istore_2
40 goto 46 (+6)
43 bipush 40
45 istore_2
46 return
```

- 如果是 1，跳转到第 7 行，得到 10，通过 goto 跳到 return，结束运行
- 如果是 2，跳转到第 10 行，得到 20，接着往下走，得到 30，通过 goto 跳到 return，结束运行（没有 break 的原因，break 就会产生 goto）
- 如果是 3，跳转到第 12 行，得到 30，通过 goto 跳到 return，结束运行

> 代码示例 2：lookupswitch 指令

```java
public void swtich2(int select){
    int num;
    switch(select){
        case 100:
            num = 10;
            break;
        case 500:
            num = 20;
            break;
        case 200:
            num = 30;
            break;
        default:
            num = 40;
    }
}
```

字节码（`lookupswitch` 会进行排序，500 放到 200 的下面）：

```java {2-6}
 0 iload_1
 1 lookupswitch 3
	100:  36 (+35)
	200:  48 (+47)
	500:  42 (+41)
	default:  54 (+53)
36 bipush 10
38 istore_2
39 goto 57 (+18)
42 bipush 20
44 istore_2
45 goto 57 (+12)
48 bipush 30
50 istore_2
51 goto 57 (+6)
54 bipush 40
56 istore_2
57 return
```

- 如果是 100，跳转到第 7 行，得到 10，通过 goto 跳到 return，结束运行
- 如果是 200，跳转到第 13 行，得到 30，通过 goto 跳到 return，结束运行
- 如果是 500，跳转到第 10 行，得到 20，通过 goto 跳到 return，结束运行

> 代码练习

```java
public void swtich3(String season){
    switch(season){
        case "SPRING":break;
        case "SUMMER":break;
        case "AUTUMN":break;
        case "WINTER":break;
    }
}
```

字节码：

```java {7-12}
  0 aload_1
  1 astore_2
  2 iconst_m1
  3 istore_3
  4 aload_2
  5 invokevirtual #11 <java/lang/String.hashCode : ()I>
  8 lookupswitch 4
	-1842350579:  52 (+44)
	-1837878353:  66 (+58)
	-1734407483:  94 (+86)
	1941980694:  80 (+72)
	default:  105 (+97)
 52 aload_2
 53 ldc #12 <SPRING>
 55 invokevirtual #13 <java/lang/String.equals : (Ljava/lang/Object;)Z>
 58 ifeq 105 (+47)
 61 iconst_0
 62 istore_3
 63 goto 105 (+42)
 66 aload_2
 67 ldc #14 <SUMMER>
 69 invokevirtual #13 <java/lang/String.equals : (Ljava/lang/Object;)Z>
 72 ifeq 105 (+33)
 75 iconst_1
 76 istore_3
 77 goto 105 (+28)
 80 aload_2
 81 ldc #15 <AUTUMN>
 83 invokevirtual #13 <java/lang/String.equals : (Ljava/lang/Object;)Z>
 86 ifeq 105 (+19)
 89 iconst_2
 90 istore_3
 91 goto 105 (+14)
 94 aload_2
 95 ldc #16 <WINTER>
 97 invokevirtual #13 <java/lang/String.equals : (Ljava/lang/Object;)Z>
100 ifeq 105 (+5)
103 iconst_3
104 istore_3
105 iload_3
106 tableswitch 0 to 3
	0:  136 (+30)
	1:  139 (+33)
	2:  142 (+36)
	3:  145 (+39)
	default:  145 (+39)
136 goto 145 (+9)
139 goto 145 (+6)
142 goto 145 (+3)
145 return
```

结合上面两个例子，加强自己的理解能力吧🤣。

8 到 11 行的一大串数字是根据字符串解析出来的哈希值。

### 无条件跳转

目前主要的无条件跳转指令为 `goto`，指令 `goto` 接收两个字节的操作数，共同组成一个带符号的整数，**用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处**。

如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令 `goto_w`，它和 `goto` 有相同的作用，但是它接收 4 个字节的操作数，可以表示更大的地址范围。

指令 `jsr`、`jsr_w`、`ret` 虽然也是无条件跳转的，但主要用于 `try-finally` 语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令。

| 指令名称 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| goto     | 无条件跳转                                                   |
| goto_w   | 无条件跳转（宽索引）                                         |
| jsr      | 跳转至指定 16 位 offset位置，并将 jsr 下一条指令地址压入栈顶 |
| jsr_w    | 跳转至指定 32 位 offer 位置，并将 jsr_w 下一条指令地址压入栈顶 |
| ret      | 返回至由指定的局部变量所给出的指令位置（一般与 jsr、jsr_w 联合使用） |

> 代码示例 1：goto 指令（int）

```java
public void whileInt() {
    int i = 0;
    while (i < 100) {
        String s = "youngkbt.cn";
        i++;
    }
}
```

字节码：

```java {5}
 0 iconst_0
 1 istore_1
 2 iload_1
 3 bipush 100
 5 if_icmpge 17 (+12)
 8 ldc #17 <youngkbt.cn>
10 astore_2
11 iinc 1 by 1
14 goto 2 (-12)
17 return
```

首先 i 存入局部变量表的位置 1，然后通过 `if_icmpge` 判断 i 是否大于等于 100？

- 如果小于 100，则不跳转，继续往下走，给 s 赋值为 `youngkbt.cn`，并存入局部变量表的位置 2 后，令局部变量表的位置 1（i）进行一次加 1，最后通过 goto 指令回到第 3 行，重新让加过 1 的 i 入栈，重新判断是否大于等于 100
- 如果大于等于 100，则直接跳转到第 10 行，结束运行

> 代码示例 2：goto 指令（double）

```java
public void whileDouble() {
    double d = 0.0;
    while(d < 100.1) {
        String s = "youngkbt.cn";
        d++;
    }
}
```

字节码：

```java {5,6}
 0 dconst_0
 1 dstore_1
 2 dload_1
 3 ldc2_w #18 <100.1>
 6 dcmpg
 7 ifge 20 (+13)
10 ldc #17 <youngkbt.cn>
12 astore_3
13 dload_1
14 dconst_1
15 dadd
16 dstore_1
17 goto 2 (-15)
20 return
```

步骤和代码示例 1 类似，试试自己练习理解。

> 代码示例 3：goto 指令（for 循环）

```java
public void printFor() {
    short i;
    for (i = 0; i < 100; i++) {
        String s = "youngkbt.cn";
    }
}
```

字节码：

```java {5}
 0 iconst_0
 1 istore_1
 2 iload_1
 3 bipush 100
 5 if_icmpge 19 (+14)
 8 ldc #17 <youngkbt.cn>
10 astore_2
11 iload_1
12 iconst_1
13 iadd
14 i2s
15 istore_1
16 goto 2 (-14)
19 return
```

和上面两个例子同理。

> 代码练习

```java
// 思考：如下两个方法的操作有何不同？
public void whileTest(){
    int i = 1;
    while(i <= 100){

        i++;
    }
    // 可以继续使用i
}
public void forTest(){
    for(int i = 1;i <= 100;i++){

    }
    // 不可以继续使用 i
}
// 更进一步
public void doWhileTest(){
    int i = 1;
    do{
        i++;
    }while(i <= 100);
}
```

字节码：

```java {6,15,25}
// whileTest
 0 iconst_1
 1 istore_1
 2 iload_1
 3 bipush 100
 5 if_icmpgt 14 (+9)
 8 iinc 1 by 1
11 goto 2 (-9)
14 return
// forTest
 0 iconst_1
 1 istore_1
 2 iload_1
 3 bipush 100
 5 if_icmpgt 14 (+9)
 8 iinc 1 by 1
11 goto 2 (-9)
14 return
// doWhileTest
 0 iconst_1
 1 istore_1
 2 iinc 1 by 1
 5 iload_1
 6 bipush 100
 8 if_icmple 2 (-6)
11 return
```

## 异常处理指令

### 抛出异常指令

**`athrow` 指令**。

在 Java 程序中显式抛出异常的操作（throw 语句）都是由 `athrow` 指令来实现的。

除了使用 throw 语句显式抛出异常情况之外，**JVM 规范还规定了许多运行时一场会在其它 Java 虚拟机指令检测到异常状况时自动抛出**。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出 `ArithmeticException` 异常。

注意：

正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是 **在抛异常时，Java 虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上**。

异常及异常的处理：

- 过程一：异常对象的生成过程：`throw`（手动 / 自动），通过指令 `athrow` 处理
- 过程二：异常的处理：抓抛模型 `try-catch-finally`，通过异常表处理

> 代码示例 1

```java
public void throwZero(int i){
    if(i == 0){
        throw new RuntimeException("参数值为0");
    }
}
```

字节码：

```java {7}
 0 iload_1
 1 ifne 14 (+13)
 4 new #2 <java/lang/RuntimeException>
 7 dup
 8 ldc #3 <参数值为0>
10 invokespecial #4 <java/lang/RuntimeException.<init> : (Ljava/lang/String;)V>
13 athrow
14 return
```

`ifne` 判断 i 不等于 0 跳转出去，等于 0 则往下走，new 一个异常，然后「复制一份、ldc 将字符串存入栈中，最后这两个都在第 6 行出栈」，只剩下 new 得到异常，通过 `athrow` 抛出给调用 `throwZero` 方法的方法。

> 代码示例

```java
public void throwOne(int i) throws RuntimeException,IOException{
    if(i == 1){
        throw new RuntimeException("参数值为1");
    }
}
```

字节码：

```java {3}
 0 iload_1
 1 iconst_1
 2 if_icmpne 15 (+13)
 5 new #2 <java/lang/RuntimeException>
 8 dup
 9 ldc #5 <参数值为1>
11 invokespecial #4 <java/lang/RuntimeException.<init> : (Ljava/lang/String;)V>
14 athrow
15 return
```

解析和代码示例 1 一样，只不过 `if_icmpne` 替换了 `ifne` 指令。

### 异常处理与异常表

> 异常处理

在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（早期使用 jsr、ret 指令），而是 **采用异常表来完成的**。

> 异常表

如果一个方法定义了一个 `try-catch` 或者 `try-finally` 的异常处理，就会创建一个异常表。它包含了每个异常处理或者 finally 块的信息。异常表保存了每个异常处理信息。比如：

- 起始位置
- 结束位置
- 程序计数器记录的代码处理的偏移地址
- 被捕获的异常类在常量池中的索引

**当一个异常被抛出时，JVM 会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧**，并且异常会重新抛给上层调用的方法(在调用方法栈帧)。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个县城将终止。如果这个异常在最后一个非守护线程里抛出，将会导致 JVM 自己终止，比如这个线程是个 main 线程。

**不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行**。在这种情况下， 如果方法结束后没有抛出异常，仍然执行 finally 块，在 return 前，它直接跳到 finally 块来完成目标。

> 代码示例 1

```java
public void tryCatch(){
    try{
        File file = new File("d:/hello.txt");
        FileInputStream fis = new FileInputStream(file);

        String info = "hello!";
    }catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    catch(RuntimeException e){
        e.printStackTrace();
    }
}
```

字节码（看注解）：

```java
 0 new #8 <java/io/File>    // new 一个 File 对象，将地址放入栈中
 3 dup					    // 复制一份 File 的地址放入栈中
 4 ldc #9 <d:/hello.txt>    // 字符串 d:/hello.txt 地址入栈
 6 invokespecial #10 <java/io/File.<init> : (Ljava/lang/String;)V> // 构调用造器后，复制的地址和字符串出栈
 9 astore_1  			    // 将 File 对象地址存入局部变量表（第一行 new 的 File 地址）
10 new #11 <java/io/FileInputStream> // new FileInputStream 对象的地址入栈
13 dup  				    // 复制一份 FileInputStream 对象的地址入栈
14 aload_1				    // 将局部变量表的 File 地址入栈
15 invokespecial #12 <java/io/FileInputStream.<init> : (Ljava/io/File;)V> // 复制的地址出栈
18 astore_2 			    // 将 FileInputStream 对象地址存入局部变量表（第 6 行）
19 ldc #13 <hello!>         // 字符串 hello! 地址入栈
21 astore_3					// 字符串 hello! 地址存入局部变量表
22 goto 38 (+16)            // 直接跳转到 return 初，结束运行
    
// ************************ 异常表的处理 ********************
25 astore_1                
26 aload_1
27 invokevirtual #15 <java/io/FileNotFoundException.printStackTrace : ()V>
30 goto 38 (+8)
33 astore_1
34 aload_1
35 invokevirtual #16 <java/lang/RuntimeException.printStackTrace : ()V>
// ********************************************

38 return
```

我们可以看到执行到第 13 行后直接跳转到 return，结束运行，那么 16 行到 22 行的处理指令不执行了吗？

这就需要到异常表，我们打开异常表，如图：

![image-20220128234817333](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128234818.png)

看到异常表的 25 和 33 指向了字节码代码块的 16 行到 22 行，所以如果出现了异常，那么由异常表进行处理，直接跳转到对应的行数。

另外说明：异常表的 `FileNotFoundException` 和 `RuntimeException` 异常监听的都是 0 - 22 行（字节码行数）的代码。

这也就是为什么我们无法在字节码看出异常处理的执行，它交给异常表执行。

> **代码示例 2**：面试常客

```java
//思考：如下方法返回结果为多少？
public static String func() {
    String str = "hello";
    try{
        return str;
    }
    finally{
        str = "kele";
    }
}

public static void main(String[] args) {

    System.out.println(func()); // hello
}
```

字节码：

```java
 0 ldc #17 <hello>  // hello 地址入栈
 2 astore_0			// hello 存入局部变量表位置 0，并出栈
 3 aload_0			// hello 出现入栈
 4 astore_1			// hello 存入局部变量表位置 1，并出栈
 5 ldc #18 <kele>   // kele 入栈
 7 astore_0			// kele 覆盖局部变量表位置 0 的 hello
 8 aload_1			// 局部变量表位置 1 的 hello 入栈
 9 areturn			// 输出 hello
// ************************ 异常表的处理 ********************
10 astore_2
11 ldc #18 <kele>
13 astore_0
14 aload_2
15 athrow
// ********************************************
```

通过字节码我们得出，局部变量表存有 hello 和 kele 的地址，但是最终返回的是 hello 的地址。

第 10 行到第 14 行由异常表进行跳转执行。

![image-20220128235702095](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220128235703.png)

## 同步控制指令

`monitor` 指令。

Java 虚拟机支持两种同步结构：**方法级同步** 和 **方法内部一段指令序列的同步**，这两种同步都是使用 `monitor` 来支持的。

### 方法级的同步

方法级的同步：**是隐式的**，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 `ACC_SYNCHRONIZED` 访问标志得知一个方法是否声明为同步方法。

当调用方法时，调用指令将会检查方法的 `ACC_SYNCHRONIZED` 访问标志是否设置。

- 如果设置了，执行线程将先持有同步锁，然后执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁
- 在方法执行期间，执行线程持有了同步锁，其它任何线程都无法再获得同一个锁
- 如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放

举例：

```java
private int i = 0;
public synchronized void add() {
  i++;
}
```

对应字节码：

```java
0 aload_0
1 dup
2 getdield #2 <com/youngkbt/java1/SynchronizedTest.i>
5 iconst_1
6 iadd
7 putfield #2 <com/youngkbt/java1/SynchronizedTest.i>
10 return
```

这段代码和普通的无同步操作的代码没有什么不同，没有使用 `monitorenter` 和 `monitorexit` 进行同步区控制。

这是因为，对于同步方法而言，当虚拟机 **通过方法的访问标识符判断是一个同步方法时，会自动在方法调用前进行加锁**，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。

因此，对于同步方法而言，`monitorenter` 和 `monitorexit` 指令是隐式存在的，并未直接出现在字节码中，而是交由访问标志来判断是否同步。

### 方法内指定指令序列的同步

同步一段指令集序列：通常是由 Java 中的 synchronized 语句块来表示的。JVM 的指令集有 `monitorenter` 和 `monitorexit` 两条指令来支持 synchronized 关键字的语义。

当一个线程进入同步代码块时，它使用 `monitorenter` 指令请求进入。如果当前对象的监视器计数器为 0，则它会被准许进入，若为 1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，知道对象的监视器计数器为 0，才会被允许进入同步块。

当线程退出同步块时，需要使用 `monitorexit` 声明退出。在 Java 虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。

指令 `monitorenter` 和 `monitorexit` 在执行时，都需要在操作数栈顶压入对象，之后 `monitorenter` 和 `monitorexit` 的锁定和释放都是针对这个对象的监视器进行的。

下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程 4 离开临界区后，线程 1、2、3 才有可能进入。

![image-20220129000225708](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220129000226.png)

编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 `monitorenter` 指令都必须执行其对应的 `monitorexit` 指令，而无论这个方法是正常结束还是异常结束。

为了保证在方法异常完成时 `monitorenter` 和 `monitorexit` 指令依然可以正确配对执行，**编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常**，它的目的就是用来执行 `monitorexit` 指令。

> 代码示例

```java
private Object obj = new Object();
public void subtract(){

    synchronized (obj){
        i--;
    }
}
```

字节码：

```java {5,13,17}
 0 aload_0
 1 getfield #4 <com/youngkbt/java1/SynchronizedTest.obj : Ljava/lang/Object;>
 4 dup
 5 astore_1
 6 monitorenter
 7 aload_0
 8 dup
 9 getfield #2 <com/youngkbt/java1/SynchronizedTest.i : I>
12 iconst_1
13 isub
14 putfield #2 <com/youngkbt/java1/SynchronizedTest.i : I>
17 aload_1
18 monitorexit
19 goto 27 (+8)
// ************************ 异常表的处理 ********************
22 astore_2
23 aload_1
24 monitorexit
25 aload_2
26 athrow
// ********************************************
27 return
```

第 5 行执行 `monitorenter` 指令后，监视器计数器加 1 形成锁，其他的线程无法进入，执行完代码后来带第 13 行的 `monitorexit` 指令，将监视器计数器变成 0，即释放锁，其他线程将才可以进入。

第 18 行的 `monitorexit` 指令是针对发生异常的情况，走不到第 13 行的 `monitorexit` 而出现的，即防止出现异常却无法释放锁的 bug。

虽然代码里没有抛出异常或者捕获异常，但是依然会有异常处理机制，如下异常表图：

![image-20220129001636535](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Java/20220129001638.png)

从上图我们知道，异常监听了 7 - 19 行（字节码行数）的代码，如果出现异常，则直接跳转到 22 行（字节码行数）处。
