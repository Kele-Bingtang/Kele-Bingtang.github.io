---
title: Docker - 常用命令
date: 2021-11-19 17:31:25
permalink: /docker/commands/
categories:
  - Docker
tags: 
  - 容器部署
---

[[TOC]]



## Docker运行流程

![image-20211119173310617](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211119173339.png)



## Docker帮助命令

查看 docker 信息（版本、结构等）

```sh
docker info
```

查看 docker 版本

```sh
docker version
```

查看 docker 所有命令

```sh
docker --help
```

可以看出 docker 执行命令格式： `docker [options] command（具体命令）`

查看 docker run 命令

```sh
docker run --help
```

查看其他类似命令

```
docker xxx --help
```



## Docker镜像命令

当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。

::: note 切记

镜像的唯一标识是 id 和 tag（版本）。（大部分情况下）能以 id 操作镜像，则也能以 tag 操作镜像，反之亦然。

下面的例子可能只写一个标识如 id，忽略另一个，但请记住，两者使用任意一个标识都可以。

::: right

2021-11-19 @Young Kbt

:::

指令语法标签介绍：

- [xxx]：xxx 是可选的
- &lt;xxx>：xxx 是必选的
- |：或者
- &：和

### 镜像本机

查看本机中所有镜像命令格式：`docker images [options] [镜像名]`

```sh
# 列出所有本地镜像格式
docker images [options] [镜像名]

# 列出所有镜像（包含中间映像层）
docker iamges -a

# 只显示出镜像 id
docker iamges -q

# 专门查询某个镜像
docker images <镜像名>
```

> **例子 1：查询全部镜像**

我预先下载了 mysql 的最新版

```sh {2}
# 执行命令
docker images

# 返回结果
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
mysql         latest    b05128b000dd   2 days ago    516MB
hello-world   latest    feb5d9fea6a5   8 weeks ago   13.3kB
```

> **例子 2：查询 MySQL 镜像**

```sh {2}
# 执行命令
docker images mysql

# 返回结果
REPOSITORY   TAG       IMAGE ID       CREATED      SIZE
mysql        latest    b05128b000dd   2 days ago   51
```

各个选项说明:

- REPOSITORY：镜像的仓库源
- TAG：镜像的标签，同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本。**唯一**
- IMAGE ID：镜像 ID。**唯一**
- CREATED：镜像的创建时间
- SIZE：镜像的大小

### 镜像搜索

> **Docker Hub 网页搜索镜像**

![image-20211119180949897](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211119180950.png)

![image-20211119181104957](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211119181106.png)

![image-20211119181529265](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211119181540.png)



> **命令搜索镜像**

去 Docker Hub 上查询镜像命令格式：`docker search [options] <镜像名>[:TAG]`

```sh
# 查询指定的镜像格式
docker search [options] <镜像名>[:TAG]

# 列出收藏数不少于指定值的镜像
docker search -s <收藏数/指定值> <镜像名>

# 显示完整的镜像信息
docker search --no-trunc <镜像名>
```

通过命令无法列出版本，只能指定查询某个版本是否存在，所以建议还是去 Docker Hub 查看版本号

```sh
docker search <镜像名:版本号>
```

> **例子 1：查询 MySQL**

```sh {2}
# 执行命令
docker search mysql

# 返回结果
NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql                             MySQL is a widely used, open-source relation…   11706     [OK]       
mariadb                           MariaDB Server is a high performing open sou…   4457      [OK]       
mysql/mysql-server                Optimized MySQL Server Docker images. Create…   869                  [OK]
phpmyadmin                        phpMyAdmin - A web interface for MySQL and M…   373       [OK]       
centos/mysql-57-centos7           MySQL 5.7 SQL database server                   92                   
mysql/mysql-cluster               Experimental MySQL Cluster Docker images. Cr…   89                   
centurylink/mysql                 Image containing mysql. Optimized to be link…   59                   [OK]
databack/mysql-backup             Back up mysql databases to... anywhere!         52                   
prom/mysqld-exporter                                                              43                   [OK]
deitch/mysql-backup               REPLACED! Please use http://hub.docker.com/r…   41                   [OK]
tutum/mysql                       Base docker image to run a MySQL database se…   35                   
linuxserver/mysql                 A Mysql container, brought to you by LinuxSe…   34                   
schickling/mysql-backup-s3        Backup MySQL to S3 (supports periodic backup…   31                   [OK]
mysql/mysql-router                MySQL Router provides transparent routing be…   23                   
centos/mysql-56-centos7           MySQL 5.6 SQL database server                   21                   
arey/mysql-client                 Run a MySQL client from a docker container      19                   [OK]
fradelg/mysql-cron-backup         MySQL/MariaDB database backup using cron tas…   16                   [OK]
genschsa/mysql-employees          MySQL Employee Sample Database                  8                    [OK]
yloeffler/mysql-backup            This image runs mysqldump to backup data usi…   7                    [OK]
openshift/mysql-55-centos7        DEPRECATED: A Centos7 based MySQL v5.5 image…   6                    
devilbox/mysql                    Retagged MySQL, MariaDB and PerconaDB offici…   3                    
ansibleplaybookbundle/mysql-apb   An APB which deploys RHSCL MySQL                3                    [OK]
jelastic/mysql                    An image of the MySQL database server mainta…   2                    
centos/mysql-80-centos7           MySQL 8.0 SQL database server                   2                    
widdpim/mysql-client              Dockerized MySQL Client (5.7) including Curl…   1                    [OK]
```

- NAME: 镜像仓库源的名称

- DESCRIPTION: 镜像的描述

- OFFICIAL: 是否为官方发布，OK 代表是官方发布，空白代表是个人发布

- STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思

- AUTOMATED: 是否自动构建

### 镜像下载

从远程仓库下载镜像命令格式：`docker pull <镜像名>[:TAG | @DIGEST]`

- TAG：版本号、标签

- DIGEST：摘要

推荐通过「版本号」下载镜像，如果不指定版本，默认最新版 `latest`

```sh
# 下载镜像格式
docker pull <镜像名>[:TAG | @DIGEST]

# 通过「版本号」下载镜像
docker pull <镜像名:TAG>

# 通过「摘要」下载镜像
docker pull <镜像名:@DIGEST>
```

> **查看摘要**

![image-20211119182221059](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211119190244.png)

![image-20211119182304571](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211119182305.png)

> **例子 1：通过「版本」下载 MySQL 的 latest 版本**

```sh {2,5}
# 执行命令
docker pull mysql:latest

# 不指定版本号，默认下载 latest 版本
docker pull mysql

# 返回结果
latest: Pulling from library/mysql
a10c77af2613: Pull complete 
b76a7eb51ffd: Pull complete 
258223f927e4: Pull complete 
2d2c75386df9: Pull complete 
63e92e4046c9: Pull complete 
f5845c731544: Pull complete 
bd0401123a9b: Pull complete 
3ef07ec35f1a: Pull complete 
c93a31315089: Pull complete 
3349ed800d44: Pull complete 
6d01857ca4c1: Pull complete 
4cc13890eda8: Pull complete 
Digest: sha256:aeecae58035f3868bf4f00e5fc623630d8b438db9d05f4d8c6538deb14d4c31b
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest
```

> **例子 2：通过「摘要」下载 MySQL 的 latest 版本**

```sh {2}
# 执行命令
docker pull mysql:sha256:1ea233722275afb6bf54bdb53bcb162bdb9f3ceed69c64836250f72bc641f63a

# 返回结果
latest: Pulling from library/mysql
a10c77af2613: Pull complete 
b76a7eb51ffd: Pull complete 
258223f927e4: Pull complete 
2d2c75386df9: Pull complete 
63e92e4046c9: Pull complete 
f5845c731544: Pull complete 
bd0401123a9b: Pull complete 
3ef07ec35f1a: Pull complete 
c93a31315089: Pull complete 
3349ed800d44: Pull complete 
6d01857ca4c1: Pull complete 
4cc13890eda8: Pull complete 
Digest: sha256:aeecae58035f3868bf4f00e5fc623630d8b438db9d05f4d8c6538deb14d4c31b
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest
```

### 镜像删除

在本地仓库删除镜像命令格式：

- 完整：`docker image rm [options] <镜像名>[:TAG | IMAGE ID]`

- 简写： `docker rmi [options] <镜像名>[:TAG | IMAGE ID]`

`i` 指的是 image

```sh
# 删除镜像 完整格式
docker image rm [options] <镜像名>[:TAG | IMAGE ID]

# 删除镜像 简写格式
docker rmi [options] <镜像名>[:TAG | IMAGE ID]

# 强制删除镜像
docker image rm -f <镜像名>
docker rmi -f <镜像名>

# 通过「版本号」删除镜像
docker rmi <镜像名>:TAG

# 通过「镜像 id」删除镜像
docker rmi <镜像名>:IMAGE ID
```

> **例子 1：直接删除 hello-world 镜像**

```sh {2,4}
# 完整格式
docker image rm hello-world
# 简写格式
docker rmi hello-world

# 返回结果
Error response from daemon: conflict: unable to remove repository reference "hello-world" (must force) - container 2be48e124757 is using its referenced image feb5d9fea6a5
```

返回结果报错了，原因有两点，要么是容器（container）曾经运行过（类似于 Windows 里运行的软件无法删除），要么存在镜像依赖。

两种解决方案：

- 使用强制删除镜像命令

    ```sh
    docker rmi -f hello-world
    ```

    这将会让它产生的历史容器也被删除。

    ::: note 注意

    正在运行容器的镜像无法删除，先停止运行的容器才可以强制删除对应镜像。

    ::: right

    2021-11-20 @Young Kbt

    :::

- 报错的结果已经给了容器的 id，先删除容器 id，再重新删除 hello-world 镜像

    ```sh
    docker rm 2be48e124757
    docker rmi hello-world
    ```

    删除容器不需要 `i`

> **例子 2：通过 hello-world 镜像的唯一标识符(tag、id)进行删除**

首先查询 hello-world 镜像 id

```sh {2}
# 执行命令
docker image hello-world

# 返回结果
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
hello-world   latest    feb5d9fea6a5   8 weeks ago   13.3kB
```

删除 hello-world 镜像

```sh
docker rmi hello-world:latest
# 或者
docker rmi hello-world:feb5d9fea6a5
```

> **例子 3：批量强制删除镜像**

如果不强制删除，需要先删除容器（如果容器存在）

```sh
docker rmi -f $(docker images -q)
```

`$()` 类似于 Linux 的管道符号 `|`，先执行括号里的命令，再执行外面的命令。

### 镜像命名

如果你觉得下载的镜像名或者镜像 TAG 太长，可以进行重命名。

我们可以手动新增镜像的版本，也就是设置 TAG，并改名，格式为：`docker tag <ID> | <镜像名:原来 TAG> <镜像名>:<新的 TAG>`

```sh
# 手动新增镜像的 TAG
docker tag <ID> | <镜像名:原来 TAG> <镜像名>:<新的 TAG>
```

> **例子 1：新增 hello-world 的版本 TAG 为 1.0**

```sh {2}
# 执行命令
docker tag feb5d9fea6a5 hello-world:v1.0

# 返回结果
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
hello-world   latest    feb5d9fea6a5   8 weeks ago   13.3kB
hello-world   v1.0      feb5d9fea6a5   8 weeks ago   13.3kB
```

> **例子 2：下载的镜像名和版本名太长，可以新增一个短的版本，并修改镜像名，再删除掉长的版本**

我刚下载了 Tomcat 镜像，因为版本太长，可以先新增一个短的版本名，再删除掉长的版本名，将 `8.5.73-jre8-temurin-focal` 改为 `8.5.73`，顺便把 tomcat 改为 tom

```sh {6,18}
# 执行命令
docker images tomcat

# 返回结果
REPOSITORY    TAG                         IMAGE ID       CREATED        SIZE
tomcat        8.5.73-jre8-temurin-focal   7ec084df520c   24 hours ago   249MB

# 新增短版本
docker tag 7ec084df520c tom:8.5.73
# 删除长版本
docker rmi tomcat:8.5.73-jre8-temurin-focal

# 查询查看镜像
docker images tom

# 返回结果
REPOSITORY    TAG                         IMAGE ID       CREATED        SIZE
tom        	  8.5.73                      7ec084df520c   24 hours ago   249MB
```

### 镜像打包

利用 `save` 可以打包镜像，格式有两个，分别为：

- `docker save > <名称.tar> <镜像 ID>`
- `docker save <镜像名>[:TAG | ID] -o <名称.tar>`

```sh
docker save > <名称.tar> <镜像 ID>
# 或者
docker save <镜像名>[:TAG | ID] -o <名称.tar>
```

**这里的镜像 ID 不能修改为镜像版本 TAG。**

> **例子 1：打包 hello-world 镜像为 myHelloWorld.tar**

```sh {11,13}
# 执行命令
docker images

# 返回结果
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
tomcat        8.5.73    7ec084df520c   24 hours ago   249MB
mysql         latest    b05128b000dd   2 days ago     516MB
hello-world   latest    feb5d9fea6a5   8 weeks ago    13.3kB

# 打包命令
docker save > myHelloWorld.tar feb5d9fea6a5
# 或者
docker save hello-world -o myHelloWorld.tar
```

### 镜像载入

利用 `load` 可以导入镜像，格式为：`docker load -i <名称.tar>`

```sh
docker load -i <名称.tar>
```

> **例子 1：解压 myHelloWorl.tar**

进入镜像包目录下执行命令：

```sh
docker load -i myHelloWorld.tar
# 或者
docker load < myHelloWorld.tar
```

`-i` 或者 `<` 表示从文件输入。会成功导入镜像及相关元数据，包括 tag 信息

### 镜像信息

镜像是由一层一层的文件系统组成，在下载镜像的时候就发现，下载了很多文件，那么如何查看这些文件信息呢？

在 Windows 系统，如果查看文件夹的信息，**右键 -> 属性** 即可查看文件夹里的文件个数、创建时间等信息。镜像也可以查看自己的信息。

查看镜像信息的命令格式：`docker images inspect <镜像名>[:TAG | ID]`

```sh
docker images inspect <镜像名>[:TAG | ID]

# 可以简写
docker inspect <镜像名>[:TAG | ID]
```

> **例子 1：查看 tomcat 的组成文件**

```sh {11}
# 执行命令
docker images

# 返回结果
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
tomcat        8.5.73    7ec084df520c   24 hours ago   249MB
mysql         latest    b05128b000dd   2 days ago     516MB
hello-world   latest    feb5d9fea6a5   8 weeks ago    13.3kB

# 查看 tomcat 的组成文件
docker image inspect tomcat:8.5.73

# 返回结果太长，自行实践
......
```

## Docker容器命令

::: note 切记

容器的唯一标识是 id 和 names（名字）。（大部分情况下）能以 id 操作容器，则也能以 name 操作容器，反之亦然。

内容例子可能只写一个标识如 id，忽略另一个，但请记住，两者使用任意一个标识都可以。

::: right

2021-11-19 @Young Kbt

:::

### 容器启动

启动容器内容比较长，大纲如下：

- 概念
- 简单启动，不涉及后台启动，端口映射。外界无法访问该容器
- 宿主机端口与容器端口映射
- 后台启动
- 指定名称启动

> **概念**

![image-20211120015120052](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211120015121.png)

首先我们要知道，Docker 启动一个容器，这个容器与操作系统是隔离的，比如 Tomcat 容器的端口是 8080，操作系统的 IP 是 `http://192.168.199.27`，则访问 Tomcat 的界面 `http://192.168.199.27:8080` 是失败的，这就是容器的隔离效果。你访问的是操作系统的 8080 端口，不是容器的 8080 端口。所以 **我们在启动容器时要将容器的端口和操作系统的端口进行绑定（映射）**，这样，外界访问操作系统的端口，就会转发给容器的端口。

通过镜像启动一个容器，格式为：`docker run [options] <镜像名[:tag | 镜像 id]>`

```sh
docker run [options] <镜像名[:tag | 镜像 id]>
			-p       # 指定端口号，将容器的端口和操作系统端口进行绑定
			-d       # 启动守护式容器，在后台启动容器
			--name   # 为容器起一个别名
			-it      # 打开窗口以交互模式启动容器，进入容器进程内容会有讲解
			--restart=always     # 固定格式，容器一旦关闭就会自启动，一般用于经常发生意外而宕机的容器
			--rm     # 容器启动成功并进入容器，再退出来后，容器自动停止并删除，一般在测试情况下使用

# 完整格式
docker run -p 系统端口:容器端口 -p 系统端口:容器端口 ... -d --name 容器别名 镜像名:tag | 镜像 id
```

其中 tag（TAG） 或者容器 id（IMAGE ID）选一个即可。

**options 常用参数说明：**

| 参数       | 说明                                                         |
| :--------- | ------------------------------------------------------------ |
| -d         | 启动守护式容器，在后台启动容器，并返回容器的id！             |
| -i         | 以交互模式运行容器，通过和 -t 一起使用                       |
| -t         | 给容器重新分配一个终端，通常和 -i 一起使用                   |
| -P         | 随机端口映射（大写）                                         |
| -p         | 指定端口映射（小写），将容器的端口和操作系统端口进行绑定（映射），多个 `-p` 可以指定多个端口号 |
| --name="x" | 给容器指定一个名字，如果不设置别名，启动容器会自动给该容器取一个名字 |

> **简单启动**

简单启动一个容器，不涉及后台启动，端口映射，外界无法访问该容器。

```sh {2,9,12,15}
# 执行命令
docker images tomcat

# 返回结果
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
tomcat       8.5.73    7ec084df520c   24 hours ago   249MB

# 启动命令 1，默认启动 latest 版本
docker run tomcat

# 启动命令 2，启动 8.5.73 版本
docker run hello-world:8.5.73

# 启动命令 3，启动 id 为 7ec084df520c 的镜像
docker run hello-world:7ec084df520c
```

> **宿主机端口与容器端口映射**

如果想外界访问容器，比如容器启动了 Tomcat，外界想访问 Tomcat，则需要将 Tomcat 容器和操作系统端口进行绑定（映射），这样，访问操作系统端口就会转发到容器端口。

用 `-p` 进行映射。

```sh
docker run -p 8080:8080 tomcat:8.5.73

# 如果想多个映射
docker run -p 8080:8080 -p 8081:8080 tomcat:8.5.73
```

8080/8080 中前面的 8080 是操作系统的端口，后面的 8080 端口是容器的端口，操作系统的端口只要不占用，随便写，但是容器的端口是固定的。

此时启动还是前台启动。

> **后台启动**

前台启动导致无法操作界面，只能看控制台输出发呆，所以需要后台启动

```sh
docker run -p 8080:8080 -d tomcat:8.5.73
```

> **指定名称启动**

**如何精确找到并操作某一个 Docker 容器？**

- 容器 id
- 容器名称

可以通过 id 操作容器，但是启动容器时会自动生成随机的 id，很难记住，不可能每次想操作容器都要查看一下容器的 id，所以容器的名称非常重要，默认启动容器会自动生成随机的名称，我们也可以指定名称，通过 `--name` 选项

```sh {2}
# 启动 tomcat
docker run -d --name tomcat01 tomcat:8.5.73

# 查看容器运行状态，后面有讲解
docker ps

# 返回容器运行状态
CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS         PORTS    NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   10 seconds ago   Up 9 seconds    ...     tomcat01
```

> **交互模式启动容器**

在启动容器的时候，我们可以启动完成后 **直接进入容器内部**。使用 `-it` 即可实现，需要指定的容器内部使用窗口如 shell 窗口、bash 窗口。

```sh {2}
# 执行命令
docker run -it tomcat:8.5.73 bash

# 此时已经进入了 Tomcat 容器内部，长什么样子呢？和 Windows 下的根目录类似
bin  BUILDING.txt  conf  CONTRIBUTING.md  lib  LICENSE  logs  native-jni-lib  NOTICE  README.md  RELEASE-NOTES  RUNNING.txt  temp  webapps  webapps.dist  work
```

::: warning

交互模式启动容器，不能加入 `-d`，否则启动后无法进入容器。 

::: right

2021-11-22 @Young Kbt

:::

上面的例子都是单独针对某个选项而言，实际使用，我们需要将它们组合在一起，如：

```sh
docker run -d  --name tomcat01 -p 8080:8080 tomcat:8.5.73
```

### 容器查看

容器查看的格式：`docker ps [options]`

**options 常用参数说明：**

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 表示 all，所有的，列出当前所有正在运行的容器 + 历史运行过的容器 |
| -l   | 显示最近创建的容器                                           |
| -n=? | 显示最近n个创建的容器                                        |
| -q   | 静默模式，返回正在运行的容器 id。                            |

```sh {2,9}
# 查看正在运行的容器
docker ps

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS         PORTS                                       NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   10 seconds ago   Up 9 seconds   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01

# 查看所有容器，包括历史运行的容器
docker ps -a

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED         STATUS                         PORTS     NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   3 minutes ago   Exited (143) 30 seconds ago              tomcat01
156e574bee6a   hello-world     "/hello"            2 hours ago     Exited (0) About an hour ago             sweet_kare

# 查看所有容器的 ID，包括历史运行的容器
docker ps -aq

# 返回结果
CONTAINER ID
1365f332be6b
156e574bee6a
```

返回结果参数名：

- CONTAINER ID：容器 id（唯一）

- IMAGE：生成容器的镜像名

- COMMAND：容器启动后，内部执行的命令

- CREATED：创建时间

- STATUS：当前状态

- PORTS：容器监听的端口

- NAMES：容器的别名

### 容器退出

| 指令     | 说明           |
| -------- | -------------- |
| exit     | 容器停止退出   |
| ctrl+P+Q | 容器不停止退出 |

### 容器再启动

容器再启动命令格式：`docker start <容器 id | 容器名>`

```sh
docker start <容器 id | 容器名>
```

首先查看历史运行的容器 id 或者名称，再启动历史运行的容器

```sh {2,10,12}
# 查看所有容器，包括曾经运行的容器
dokcer ps -a

# 返回结果
CONTAINER ID   IMAGE         COMMAND    CREATED          STATUS                      PORTS     NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   3 minutes ago   Exited (143) 30 seconds ago              tomcat01
156e574bee6a   hello-world     "/hello"            2 hours ago     Exited (0) About an hour ago             sweet_kare

# 再启动容器
docker start 1365f332be6b
# 或者
docker start tomcat01
```

### 容器停止和重启

容器正常停止命令格式：`docker stop <容器 id | 容器名>`

容器立即停止命令格式：`docker kill <容器 id | 容器名>`

容器重启命令格式：`docker restart <容器 id | 容器名>`

```sh
# 正常停止容器
docker stop <容器 id | 容器名>

# 立即停止容器
docker kill <容器 id | 容器名>

# 重启容器
docker restart <容器 id | 容器名>
```

> **例子：**

先正常停止 Tomcat 容器，再启动 Tomcat 容器，然后重启 Tomcat 容器，最后立即停止 Tomcat 容器。（这里演示 id，其实 name 也可以）

```sh {10,13,16,19}
# 查看历史运行的容器
docker ps -a

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS                         PORTS     NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   17 minutes ago   Exited (143) 11 minutes ago              tomcat01
156e574bee6a   hello-world     "/hello"            2 hours ago      Exited (0) About an hour ago             sweet_kare

# 正常停止容器
docker stop 1365f332be6b

# 启动 Tomcat 容器
docker start 1365f332be6b

# 重启容器
docker restart 1365f332be6b

# 立即停止容器
docker kill 1365f332be6b
```

如果容器处于特殊状态，立即停止 `kill` 命令可能造成严重后果。

### 容器删除和清除

容器删除命令格式：`docker rm [options] <容器 id | 容器名>`

容器清除命令格式：`docker container prune`

```sh
# 删除命令格式
docker rm [options] <容器 id | 容器名>

# 强制删除
docker rm -f <容器 id | 容器名>
```

> **例子：删除 Tomcat 的历史容器**

```sh {10}
# 查看历史运行的容器
docker ps -a

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS                         PORTS     NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   17 minutes ago   Exited (143) 11 minutes ago              tomcat01
156e574bee6a   hello-world     "/hello"            2 hours ago      Exited (0) About an hour ago             sweet_kare

# 删除
docker rm 1365f332be6b
```

有时候删除会报错，原因在于它处于运行状态，Windows 里正在运行的进程也不能删除。

**那么如何删除一个正在运行的容器呢？**

我们可以使用强制删除命令 `-f`

```sh
docker rm -f 1365f332be6b
```

**如何删除所有的历史容器呢？**

别忘了，之前提到过的 `$()`，按照数学运算符号优先级来说，括号的执行优先级很高。

```sh
docker rm -f $(docker ps -qa)
```

也有专门的清除历史容器命令：`docker container prune`

```sh {2,7}
# 执行命令
docker container prune

# 返回结果
WARNING! This will remove all stopped containers.
# 输入 y 确定清除
Are you sure you want to continue? [y/N] y

# 查询查看历史容器
docker ps -a

# 返回结果
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
```

删除容器并不会删除它的镜像，此时可以理解镜像是安装包，容器是安装后的软件，只要保存好镜像（安装包），容器（软件）删除了可以再通过镜像（安装包） `run` 出来。

### 查看容器进程

查看容器进程命令格式：`docker top <容器 id | 容器名>`

```sh
docker top <容器 id | 容器名>
```

> **查看 Tomcat 容器的进程**

```sh {9}
# 执行命令
docker ps

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED       STATUS       PORTS                                       NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   3 hours ago   Up 2 hours   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01

# 查看进程
docker top 1365f332be6b

# 返回结果
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                91412               91393               0                   00:12               ?                   00:00:02            /opt/java/openjdk/bin/java -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -classpath /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat -Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start
```

可以查看容器的一些进程信息，如 UID，已经运行时间等。

### 查看容器细节

这个命令还是很常用的，要求容器必须运行起来。

查看容器内部细节命令格式：`docker inspect <容器 id | 容器名>`

```sh
docker inspect <容器 id | 容器名>
```

> **查看 Tomcat 容器的内部细节**

首先查看 Tomcat 容器的 id 或者 names（名字）

```sh
# 执行命令
docker ps

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED             STATUS          PORTS                                       NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   About an hour ago   Up 12 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01
```

接着查看 Tomcat 容器的内部细节

```sh {2}
# 执行命令
docker inspect 1365f332be6b

# 返回结果（部分内容）
[
    {
        "Id": "1365f332be6b57943dfbfc1ececddac3a2b3c6ad12a17313a427041e27a2c044",
        "Created": "2021-11-19T15:20:53.580488665Z",
        "Path": "catalina.sh",
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 91412,
            "StartedAt": "2021-11-19T16:12:04.272096418Z",
            "FinishedAt": "2021-11-19T16:06:04.102664522Z"
        },
		"NetworkSettings": {
            "Ports": {
                "8080/tcp": [
                    {
                        "HostIp": "0.0.0.0",
                        "HostPort": "8080"
                    },
                    {
                        "HostIp": "::",
                        "HostPort": "8080"
                    }
                ]
            },
	}
]
```

 只截取一部分内容，可以看出有容器的状态，和操作系统绑定的端口等等信息。

### 查询运行日志

查询容器的 **运行** 日志命令格式：`docker logs [options] <容器 id | 容器名>`

```sh
# 查询容器的运行日志命令格式
docker logs [options] <容器 id | 容器名>

# 加入时间戳
docker logs -t <容器 id | 容器名>

# 监听日志的输出，一旦日志更新，显示在控制台上
docker logs -f <容器 id | 容器名>

# 显示日志的最后多少条数据，取决于数字
docker logs --tail 数字 <容器 id | 容器名>
```

| 参数     | 说明                                 |
| -------- | ------------------------------------ |
| -t       | 显示时间戳                           |
| -f       | 监听日志，一旦更新，立即打印在控制台 |
| --tail N | 显示日志的最后 N 条数据              |

> **例子 1：查看容器的日志(显示时间戳)**

```sh {9}
# 执行命令
docker ps

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS         PORTS                                       NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   13 hours ago   Up 5 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01

# 查看容器日志(显示时间戳)
docker logs -t 1365f332be6b
```

> **例子 2：实时监听容器的日志**

要求：先运行容器才能实时监听容器的日志

```sh {9}
# 执行命令
docker ps

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS         PORTS                                       NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   13 hours ago   Up 5 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01

# 查看容器日志(显示时间戳)
docker logs -tf 1365f332be6b
```

> **例子 3：查看日志的最后 5 行记录**

```sh
# 执行命令
docker ps

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS         PORTS                                       NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   13 hours ago   Up 5 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01

# 查看容器日志(显示时间戳)
docker logs -t --tail 5 1365f332be6b

# 返回结果
2021-11-20T04:11:38.947501511Z 20-Nov-2021 04:11:38.947 INFO [main] org.apache.catalina.startup.Catalina.load Initialization processed in 2190 ms
2021-11-20T04:11:39.030048052Z 20-Nov-2021 04:11:39.029 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service [Catalina]
2021-11-20T04:11:39.030143031Z 20-Nov-2021 04:11:39.029 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet engine: [Apache Tomcat/8.5.73]
2021-11-20T04:11:39.069039566Z 20-Nov-2021 04:11:39.068 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["http-nio-8080"]
2021-11-20T04:11:39.080909086Z 20-Nov-2021 04:11:39.080 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in 133 ms
```



### 进入容器进程

先启动 Tomcat

```sh
# 执行命令
docker ps -a

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS                        PORTS     NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   39 minutes ago   Exited (143) 34 minutes ago             tomcat01
156e574bee6a   hello-world     "/hello"            3 hours ago      Exited (0) 2 hours ago                  sweet_kare

# 启动 Tomcat
docker start 1365f332be6b
```

- 第一种命令：`docker attach`

    ```sh {9,12}
    # 执行命令
    docker ps
    
    # 返回结果
    CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMES
    1365f332be6b   tomcat:8.5.73   "catalina.sh run"   42 minutes ago   Up 20 seconds   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01
    
    # 进入容器内
    docker attach 1365f332be6b
    
    # 退出
    exit
    ```

    可以看出，该命令进入容器后，如果退出容器，容器自动结束运行。

- 第二种命令：`docker exec`，格式为：`docker exec [options] <容器 id> <容器使用的终端窗口>`

    ```sh
    docker exec [options] <容器 id> <容器使用的终端窗口>
    
    # 以交互模式运行容器，通常与 -t 一起使用
    docker exec -i <容器 id> <容器使用的终端窗口>
    
    # 分配一个伪终端，如 shell窗口、base 窗口
    docker exec -t <容器 id> <容器使用的终端窗口>
    
    # 建议一起使用
    docker exec -it <容器 id> <容器使用的终端窗口>
    ```
    
    `-i`：以交互模式运行容器，通常与 -t 一起使用
    
    `-t`：分配一个伪终端，如 shell窗口、base 窗口
    
    > **进入 Tomcat 容器内部**
    
    ```sh {2,9}
    # 执行命令
    docker exec -it 1365f332be6b bash
    
    # 进入容器内部，查看容器内部
    root@1365f332be6b:/usr/local/tomcat# ls
    bin  BUILDING.txt  conf  CONTRIBUTING.md  lib  LICENSE  logs  native-jni-lib  NOTICE  README.md  RELEASE-NOTES  RUNNING.txt  temp  webapps  webapps.dist  work
    
    # 从容器内部退出
    root@1365f332be6b:/usr/local/tomcat# exit
    
    # 查看容器是否停止运行
    docker ps
    
    # 返回结果
    CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMES
    1365f332be6b   tomcat:8.5.73   "catalina.sh run"   51 minutes ago   Up 26 seconds   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01
    ```
    
    第 6 行是不是很熟悉，就是 Tomcat 的根目录，这就是 Tomcat 容器的根目录。
    
    `exit` 退出容器后，Docker 不会停止运行容器

**区别：**

使用 `docker attach` 进入容器后，exit 退出来便容器也停止运行了。而 `docker exec` 则不会这样操作导致停止运行容器。

推荐使用 `docker exec` 命令，因为该命令退出容器终端，不会导致容器的停止。

## Docker容器高级命令

如果你是初学者，那么建议高级命令只需要看前两个，后面的高级命令涉及其他 Docker 知识，建议学完 Docker 再来看后面的几个高级命令。

### 容器文件 > 宿主机

将容器的文件拷贝到宿主机里命令格式：`docker cp <容器 id:容器路径> <宿主机目录路径>`

```sh
docker cp <容器 id:容器路径> <宿主机目录路径>
```

> **将 Tomcat 容器里的 README.md 文件拷贝到宿主机容器**

先进入 Tomcat 容器，获取 README.md 的路径

```sh
# 执行命令
docker ps

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS          PORTS                                       NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   13 hours ago   Up 14 minutes   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01

# 进入容器
docker exec -it 1365f332be6b bash

# 查看当前路径内容
oot@1365f332be6b:/usr/local/tomcat# ls

# 找到 README.md
bin  BUILDING.txt  conf  CONTRIBUTING.md  lib  LICENSE  logs  native-jni-lib  NOTICE  README.md  RELEASE-NOTES  RUNNING.txt  temp  webapps  webapps.dist  work
```

退出容器，容器内不支持 docker 命令，在外部使用命令：

```sh {2}
# 拷贝出去
docker cp 1365f332be6b:/usr/local/tomcat/README.md /opt/README.md

# 进入目录
cd /opt
ls

# 返回结果
activemq  containerd  dump.rdb  jdk  mysql  README.md  redis  rh  tomcat 杂文.txt
```

容器 id 可以用容器名替换。

### 宿主机文件 > 容器

将宿主机的文件拷贝到容器里命令格式：`docker cp <宿主机文件 | 目录> <容器 id:容器路径>`

```sh
docker cp <宿主机文件 | 目录> <容器 id:容器路径>
```

> **将宿主机的 杂文.txt 文件拷贝到 Tomcat 容器里**

杂文.txt 文件在 /opt 目录下

```sh
cd /opt
ls

# 返回结果
activemq  containerd  dump.rdb  jdk  mysql  README.md  redis  rh  tomcat 杂文.txt
```

Tomcat 容器的 id是 1365f332be6b，拷贝到的路径是 /usr/local/tomcat/

```sh
docker cp 杂文.txt 1365f332be6b:/usr/local/tomcat/

# 进入容器
docker exec -it 1365f332be6b bash

# 查看当前路径内容
oot@1365f332be6b:/usr/local/tomcat# ls

# 返回结果
bin           conf             lib      logs            NOTICE     RELEASE-NOTES  temp     webapps.dist  杂文.txt
BUILDING.txt  CONTRIBUTING.md  LICENSE  native-jni-lib  README.md  RUNNING.txt    webapps  work
```

### 数据卷与宿主机共享目录

这部分内容也放到了 [Docker - 数据卷：数据卷挂载操作](/docker/volume/#数据卷挂载操作)，那里描述得更加详细。这里通俗解释：数据卷就是 Docker 和宿主机的共享目录，这个目录双方共用。

数据卷与宿主机共享目录目录格式：`docker run [options] -v <宿主机绝对路径 | 任意别名:容器内的路径[:ro | rw]> <镜像名>`

```sh
docker run [options] -v <宿主机路径 | 任意别名:容器内的路径[:ro | rw]> <镜像名>

# 完整
docker run -d -p <宿主机端口:容器端口> --name <容器名> -v <宿主机绝对路径 | 任意别名:容器内的路径[:ro | rw]> <镜像名>
```

`ro`：代表 read-only，容器的路径只允许读，不允许写。不影响宿主机的路径可读可写

`rw`：默认值，代表可读可写

数据卷的创建有两种：

- **具体目录挂载**

    ```sh
    docker run -d -p <宿主机端口:容器端口> --name <容器名> -v <宿主机绝对路径:容器内的路径[:ro | rw]> <镜像名>
    ```

    **宿主机路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。**

    Dockerfile 是不支持这种用法，这是因为 Dockerfile 是为了移植和分享用的，因为不同操作系统的路径格式不一样，所以目前还不能支持。

    > **例子 1：具名挂载**

    ```sh
    docker run -d -p 8081:8080 --name tomcat02 -v /opt/aa:/usr/local/tomcat/webapps tomcat:8.5.73
    ```

    将 Tomcat 容器根目录下的 webapps 目录和操作系统的 `/opt/aa` 目录进行绑定。

    **特点：宿主机的的挂载目录内容覆盖到容器的挂载目录内容**

    因为 /opt/aa 目录为空，所以容器的 webapps 目录内容被 aa 目录内容覆盖，也为空。

    > **例子 2：删除容器**

    我们删除容器，看主机上数据是否会被删除

    ```sh {17}
    # 执行命令
    docker ps
    
    # 返回结果
    CONTAINER ID   IMAGE           COMMAND             CREATED          STATUS          PORTS                                       NAMES
    e2bb571eb168   tomcat:8.5.73   "catalina.sh run"   32 minutes ago   Up 31 minutes   0.0.0.0:8081->8080/tcp, :::8081->8080/tcp   tomcat02
    1365f332be6b   tomcat:8.5.73   "catalina.sh run"   18 hours ago     Up 5 hours      0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01
    
    # 删除容器
    docker rm -f e2bb571eb168
    
    # 进入 aa 目录
    cd /opt/aa
    ls
    
    # 返回结果
    docs  examples  host-manager  manager  ROOT
    ```

    说明没有删除。

- **默认目录挂载**

    ```sh
    docker run -d -p 宿主机端口:容器端口 --name 容器名 -v <任意别名:容器内的路径[:ro | rw]> <镜像名>
    ```

    任意别名是一个数据卷名字，名字可以随便写，Docker 会在 `/var/lib/docker/volumes` 目录下生成该数据卷，这是 docker 默认的数据卷目录

    > **例子 1：**

    ```sh {2}
    # 执行命令
    docker run -d -p 8082:8080 --name tomcat02 -v aa:/usr/local/tomcat/webapps tomcat:8.5.73
    
    find / -name aa
    
    # 返回结果
    /var/lib/docker/volumes/aa
    
    cd /var/lib/docker/volumes/aa_data
    ls
    
    # 返回结果
    docs  examples  host-manager  manager  ROOT
    ```

    aa 代表一个数据卷名字，可以是任意，这相当于相对路径，它会在 `/var/lib/docker/volumes` 下创建 aa 目录作为数据卷。

    **特点：容器的挂载目录内容覆盖到宿主机的挂载目录内容**



**挂载总结：**

关于到底是宿主机的挂载目录覆盖容器的挂载目录，还是反过来覆盖：

- 默认目录挂载：
    - 当宿主机挂载目录已经存在时，双方挂载完成后，**宿主机挂载目录覆盖容器挂载目录**
    - 当宿主机挂载目录不存在时，双方挂载完成后，**容器挂载目录覆盖宿主机挂载目录**
- 具体目录挂载
    - 当宿主机挂载目录无论存不存在，双方挂载完成后，**宿主机挂载目录都会覆盖容器挂载目录**

**默认目录挂载**

| 宿主机                       | 容器     | 运行结果                                 |
| ---------------------------- | -------- | ---------------------------------------- |
| 文件存在                     | 文件存在 | 挂载成功，**容器的文件内容被宿主机覆盖** |
| 目录存在                     | 目录存在 | 挂载成功，**容器的目录内容被宿主机覆盖** |
| ......                       | ......   | ......                                   |
| 文件不存在                   | 文件存在 | 挂载成功，**宿主机的文件内容被容器覆盖** |
| 目录不存在                   | 目录存在 | 挂载成功，**宿主机的目录内容被容器覆盖** |
| ......                       | ......   | ......                                   |
| 其他和 **具体目录挂载** 类似 |          |                                          |

**具体目录挂载**

| 宿主机          | 容器            | 运行结果                                                 |
| --------------- | --------------- | -------------------------------------------------------- |
| 文件存在        | 文件存在        | 挂载成功，**容器的文件内容被宿主机覆盖**                 |
| 目录存在        | 目录存在        | 挂载成功，**容器的目录内容被宿主机覆盖**                 |
| ------          | ------          | ------                                                   |
| 文件不存在      | 文件存在        | 挂载成功，**创建空文件，并覆盖掉容器的文件，导致也为空** |
| 目录不存在      | 目录存在        | 挂载成功，**创建空目录，并覆盖掉容器的文件，导致也为空** |
| ------          | ------          | ------                                                   |
| 文件存在        | 文件不存在      | 挂载成功                                                 |
| 目录存在        | 目录不存在      | 挂载成功                                                 |
| ------          | ------          | ------                                                   |
| 文件存在        | 目录存在        | 容器启动失败                                             |
| 目录存在        | 文件存在        | 容器启动失败                                             |
| ------          | ------          | ------                                                   |
| 目录/文件不存在 | 目录/文件不存在 | 挂载成功，**docker 会自动在宿主机和容器内新建目录**      |
| 目录不存在      | 文件存在        | 容器启动失败                                             |
| 目录不存在      | 目录存在        | 挂载成功，**容器内目录内容被宿主机空目录覆盖（空）**     |

### 容器打包

将容器打包成新的镜像命令格式：`docker commit -m "描述信息" -a "作者信息" <容器 id | 容器名> <自定义打包镜像名:标签/版本>`

```sh
docker commit -m "描述信息" -a "作者信息" <容器 id | 容器名> <自定义打包镜像名:标签/版本>
```

支持历史容器的打包。

> **打包 Tomcat 容器**

```sh {9}
# 执行命令
docker ps

# 返回结果
CONTAINER ID   IMAGE           COMMAND             CREATED        STATUS       PORTS                                       NAMES
1365f332be6b   tomcat:8.5.73   "catalina.sh run"   16 hours ago   Up 4 hours   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   tomcat01
 
# 打包命令
docker commit -m "打包测试" -a "YoungKbt" 1365f332be6b test-tomcat:1.0
```

::: note 技巧

操作镜像、容器时，如果使用的标识是 id，该 id 可以截取一部分使用，比如 e2bb571eb168 可以写出 e2bb，Docker 会识别出长的 id。

::: right

2021-11-20 @ Young Kbt

:::

### 日志清除

使用了 Docker，那么容器里的日志就会交给 Docker 管理，如 Nginx 本身的 log 文件无法查看日志信息，而是由 Docker 管理。

查看 Docker 管理的日志及大小命令

```sh
find /var/lib/docker/containers/ -name *-json.log |xargs du -sh
```

返回结果如下：

```sh
4.0K	/var/lib/docker/containers/3cfffd7ad7d2189e7e526d97f7db98e8ef555fd4386ba66f152466274ffd844b/3cfffd7ad7d2189e7e526d97f7db98e8ef555fd4386ba66f152466274ffd844b-json.log
4.0K	/var/lib/docker/containers/d2379d7c0bd11aa4ae6ade24c98552b0f433d57fe6131f93ca56924b02e84e43/d2379d7c0bd11aa4ae6ade24c98552b0f433d57fe6131f93ca56924b02e84e43-json.log
1.1M	/var/lib/docker/containers/4e46cce44b2df1f8055a2fc2a5649ec62d5a3f9a2c5fbb97c1c1d791cbe73be8/4e46cce44b2df1f8055a2fc2a5649ec62d5a3f9a2c5fbb97c1c1d791cbe73be8-json.log
```

可以看到 有一个日志文件是 1.1M，随着时间可能会越来越大，所以我们学会如何清理日志文件，如清除上方的 1.1M 的日志文件

```sh
cat /dev/null > /var/lib/docker/containers/4e46cce44b2df1f8055a2fc2a5649ec62d5a3f9a2c5fbb97c1c1d791cbe73be8/4e46cce44b2df1f8055a2fc2a5649ec62d5a3f9a2c5fbb97c1c1d791cbe73be8-json.log
```

上面是手动清除，比较麻烦，所以我们可以写一个定时任务，到某个特定时间，就会自动清除所有或者指定的日志文件内容。

下面是定时任务清除所有的日志文件的脚本，我们叫它 `clean_docker_logs.sh`，我放在 `/opt` 目录下

```sh
cd /opt
vim clean_docker_logs.sh
```

脚本内容：

```sh
#!/bin/bash
echo "======== start clean docker containers logs ========"  
logs=$(find /var/lib/docker/containers/ -name *-json.log)
for log in $logs
    do
        echo "clean logs : $log"  
        cat /dev/null > $log
    done
echo "======== end clean docker containers logs ========" 
```

写完脚本后，默认是不允许执行的，我们必须开启 `x` 权限

```sh
chmod +x clean_docker_logs.sh
```

然后你可以执行一次试试，看是否报错之类的

```
./clean_docker_logs.sh
```

如果不报错，则开启定时任务

```sh
# 进入定时任务列表
crontab -e

# 添加如下内容
0 3 */30 * * sh /opt/clean_docker_logs.sh
```

每 30 天运行一次 在凌晨 3 点 0 分开始运行，你可以更改内容的参数，实现在不同的时间执行该脚本。

总之，使用 `cat /dev/null > 日志路径` 命令进行清除，如果你想定时清除某个日志文件，可自由发挥这个命令。



### 权限赋予

> **普通用户权限赋予**

第一次安装 Docker，那么只有 root 用户才能启动 Docker 容器，而如何让普通用户启动 Docker 呢，我们需要将普通用户放入 docker 组即可。没有这个组就创建它

```sh
groupadd docker
usermod -a -G docker <普通用户>		 # 将普通用户加入到 docker 用户组中
systemctl restart docker    		# 重启 Docker，使得权限生效
```

-a 是追加，普通用户加入 docker 组后，不会退出原来所在的组。

-G 是指定组名。

然后这个用户就可以使用 Docker 相关命令。 

> **容器内权限赋予**

Docker 容器里的权限规定：宿主机中，哪个用户启动 Docker 容器，那么这个容器的用户权限就是启动它的宿主机用户权限。

通俗理解，宿主机哪个用户启动 Docker 容器，那么容器里的权限就是启动用户的权限。

我们每次启动 Docker 容器后，进入容器时会发现，显示的是 root 用户，其实这个 root 用户就是宿主机启动时使用的用户

![image-20211210160825332](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211210160903.png)

看图我们发现，我是 kbt 用户，但是进入容器后，发现变成 root 用户，其实这个 root 用户就是宿主机的 kbt 用户（我用 kbt 用户启动这个容器）。

那么问题来了，我以 kbt 用户启动一个容器，那么这个容器内的用户就是 kbt 用户，假设我希望容器的用户权限是宿主机的 root 权限，那么怎么赋予呢？

启动用户时使用 `--privileged=true` 指令可以解决。

```sh
# 切换 kbt 普通用户
su kbt
# 启动容器的时候，赋予 root 权限
docker run -d --privileged=true tomcat:8.5.73
```

此时虽然切换了 kbt 用户启动容器，但是使用了 `--privileged=true` 指令，则该容器内部的用户权限是宿主机的 root 用户权限，不再是 kbt 普通用户权限。

大约在 0.6 版，privileged 被引入 Docker，使用该参数，容器内的 root 拥有真正的 root 权限，否则，容器内的 root 只是外部的一个普通用户权限。

privileged 启动的容器，允许你在 Docker 容器中启动 Docker 容器，这就是真正的 root 权限带来的效果。


## 常用命令总结

![img_29](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211120173905.png)



| 命令    | 官方说明                                                     | 解释                                                         |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| attach  | Attach local standard input, output, and error streams to a running container | 当前 shell 下 attach 连接指定运行镜像                        |
| build   | Build an image from a Dockerfile                             | 通过 Dockerfile 定制镜像                                     |
| commit  | Create a new image from a container's changes                | 提交当前容器为新的镜像                                       |
| cp      | Copy files/folders between a container and the local filesystem | 从容器中拷贝指定文件或者目录到宿主机中                       |
| create  | Create a new container                                       | 创建一个新的容器，同 run，但不启动容器                       |
| diff    | Inspect changes to files or directories on a container's filesystem | 查看 docker 容器变化                                         |
| events  | Get real time events from the server                         | 从 docker 服务获取容 器实时事件                              |
| exec    | Run a command in a running container                         | 在已存在的容器上运行命令                                     |
| export  | Export a container's filesystem as a tar archive             | 导出容器的内 容流作为一个 tar 归档文件[对应 import ]         |
| history | Show the history of an image                                 | 展示一个镜像形成历史                                         |
| images  | List images                                                  | 列出系统当前镜像                                             |
| import  | Import the contents from a tarball to create a filesystem image | 从 tar包中的内容创建一个新的文件系统映像[对应export]         |
| info    | Display system-wide information                              | 显示系统相关信息                                             |
| inspect | Return low-level information on Docker objects               | 查看容器详细信息                                             |
| kill    | Kill one or more running containers                          | 杀掉 指定 docker 容器                                        |
| load    | Load an image from a tar archive or STDIN                    | 从一个 tar 包中加载一 个镜像[对应 save]                      |
| login   | Log in to a Docker registry                                  | 登陆一个 docker 源服务器                                     |
| logout  | Log out from a Docker registry                               | 从当前 Docker registry 退出                                  |
| logs    | Fetch the logs of a container                                | 输出当前容器日志信息                                         |
| pause   | Pause all processes within one or more containers            | 暂停容器                                                     |
| port    | List port mappings or a specific mapping for the container   | 查看映射端口对应的容器内部源端口                             |
| ps      | List containers                                              | 列出容器列表                                                 |
| pull    | Pull an image or a repository from a registry                | 从docker镜像源服务器拉取指定镜像或者库镜像                   |
| push    | Push an image or a repository to a registry                  | 推送指定镜像或者库镜像至docker源服务器                       |
| rename  | Rename a container                                           | 给一个容器改名                                               |
| restart | Restart one or more containers                               | 重启运行的容器                                               |
| rm      | Remove one or more containers                                | 移除一个或者多个容器                                         |
| rmi     | Remove one or more images                                    | 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] |
| run     | Run a command in a new container                             | 创建一个新的容器并运行 一个命令                              |
| save    | Save one or more images to a tar archive (streamed to STDOUT by default) | 保存一个镜像为一个 tar 包[对应 load]                         |
| search  | Search the Docker Hub for images                             | 在 docker hub 中搜 索镜像                                    |
| start   | Start one or more stopped containers                         | 启动容器                                                     |
| stats   | Display a live stream of container(s) resource usage statistics | 显示容器资源使用统计信息的实时信息                           |
| stop    | Stop one or more running containers                          | 停止容器                                                     |
| tag     | Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE        | 给源中镜像打标签                                             |
| top     | Display the running processes of a container                 | 查看容器中运行的进程信 息                                    |
| unpause | Unpause all processes within one or more containers          | 取消暂停容器                                                 |
| update  | Update configuration of one or more containers               | 更新容器配置                                                 |
| version | Show the Docker version information                          | 查看 docker 版本号                                           |
| wait    | Block until one or more containers stop, then print their exit codes | 截取容器停止时的退出状态值                                   |

## 总结图片

如果觉得内容过于繁多或者复杂，这里提供图片形式的命令

来源：<https://www.bilibili.com/video/BV1ZT4y1K75K>

### 镜像命令图片

![image-20211120172453603](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211120172455.png)

![image-20211120172716950](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211120172720.png)

### 容器命令图片

![image-20211120172301522](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211120172307.png)

![image-20211120172319882](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211120172327.png)

![image-20211120172737409](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211120172738.png)

![image-20211120172743635](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Docker/20211120172745.png)
