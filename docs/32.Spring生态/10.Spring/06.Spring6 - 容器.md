---
title: Spring6 - 容器
date: 2023-10-27 23:29:13
permalink: /spring6/container/
categories:
  - Spring6
tags: 
  - Spring6
---

[[TOC]]

## XML 介绍

XML 是 Inversion of Control 的简写，译为「控制反转」，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。

Spring 通过 XML 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 XML 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。

XML 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。

## XML 容器

### 控制反转（XML）

- 控制反转是一种思想
- 控制反转是为了降低程序耦合度，提高程序扩展力
- 控制反转，反转的是什么

- - 将对象的创建权利交出去，交给第三方容器负责
  - 将对象和对象之间关系的维护权交出去，交给第三方容器负责

- 控制反转这种思想如何实现呢

- - DI（Dependency Injection）：依赖注入

### 依赖注入

DI（Dependency Injection）：依赖注入，依赖注入实现了控制反转的思想。

**依赖注入：**

- **指 Spring 创建对象的过程中，将对象依赖属性通过配置进行注入**

依赖注入常见的实现方式包括两种：

- 第一种：set 注入
- 第二种：构造注入

所以结论是：XML 就是一种控制反转的思想， 而 DI 是对 XML 的一种具体实现。

**Bean 管理说的是：Bean 对象的创建，以及 Bean 对象中属性的赋值（或者叫做 Bean 对象之间关系的维护）。**

### XML 容器在 Spring 的实现

Spring 的 XML 容器就是 XML思想的一个落地的产品实现。XML 容器中管理的组件也叫做 Bean。在创建 Bean 之前，首先需要创建 XML 容器。Spring 提供了 XML 容器的两种实现方式：

**BeanFactory**

这是 XML 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。

**ApplicationContext**

BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。

**ApplicationContext的主要实现类**

![iamges](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Spring6/20231027233307.png)

| 类型名                          | 简介                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| ClassPathXmlApplicationContext  | 通过读取类路径下的 XML 格式的配置文件创建 XML 容器对象       |
| FileSystemXmlApplicationContext | 通过文件系统路径读取 XML 格式的配置文件创建 XML 容器对象     |
| ConfigurableApplicationContext  | ApplicationContext 的子接口，包含一些扩展方法 `refresh()` 和 `close()`，让 ApplicationContext 具有启动、关闭和刷新上下文的能力 |
| WebApplicationContext           | 专门为 Web 应用准备，基于 Web 环境创建 XML 容器对象，并将对象引入存入 ServletContext 域中 |



## 基于 XML 管理 Bean

### 搭建子模块 Spring6-XML-xml

**搭建模块**

搭建方式如：Spring-first

**引入配置文件**

引入 Spring-first 模块配置文件：Beans.xml、log4j2.xml

**添加依赖**

```xml
<dependencies>
    <!--Spring context依赖-->
    <!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了-->
    <dependency>
        <groupId>org.Springframework</groupId>
        <artifactId>Spring-context</artifactId>
        <version>6.0.3</version>
    </dependency>

    <!--junit5测试-->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId>
        <version>5.3.1</version>
    </dependency>

    <!--log4j2的依赖-->
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>2.19.0</version>
    </dependency>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-slf4j2-impl</artifactId>
        <version>2.19.0</version>
    </dependency>
</dependencies>
```

**引入 Java 类**

引入 Spring-first 模块 Java 及 test 目录下实体类

```java
package cn.youngkbt.Spring6.Bean;

public class HelloWorld {

    public HelloWorld() {
        System.out.println("无参数构造方法执行");
    }

    public void sayHello(){
        System.out.println("helloworld");
    }
}

```

```java
package cn.youngkbt.Spring6.Bean;

import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.Springframework.context.ApplicationContext;
import org.Springframework.context.support.ClassPathXmlApplicationContext;

public class HelloWorldTest {

    private Logger logger = LoggerFactory.getLogger(HelloWorldTest.class);

    @Test
    public void testHelloWorld(){
        
    }
}
```



### 实验一：获取 Bean

#### 方式一：根据 id 获取

由于 id 属性指定了 Bean 的唯一标识，所以根据 Bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。

#### 方式二：根据类型获取

```java
@Test
public void testHelloWorld1(){
	ApplicationContext ac = new ClassPathXmlApplicationContext("Beans.xml");
    HelloWorld Bean = ac.getBean(HelloWorld.class);
    Bean.sayHello();
}
```

#### 方式三：根据 id 和类型

```java
@Test
public void testHelloWorld2(){
	ApplicationContext ac = new ClassPathXmlApplicationContext("Beans.xml");
    HelloWorld Bean = ac.getBean("helloworld", HelloWorld.class);
    Bean.sayHello();
}
```

#### 注意的地方

当根据类型获取 Bean 时，要求XML容器中指定类型的 Bean 有且只能有一个

当 XML 容器中一共配置了两个：

```xml
<Bean id="helloworldOne" class="cn.youngkbt.Spring6.Bean.HelloWorld"></Bean>
<Bean id="helloworldTwo" class="cn.youngkbt.Spring6.Bean.HelloWorld"></Bean>
```

根据类型获取时会抛出异常：

```java
org.Springframework.Beans.factory.NoUniqueBeanDefinitionException: No qualifying Bean of type 'cn.youngkbt.Spring6.Bean.HelloWorld' available: expected single matching Bean but found 2: helloworldOne,helloworldTwo
```



#### 扩展知识

如果组件类实现了接口，根据接口类型可以获取 Bean 吗？

> 可以，前提是 Bean 唯一

如果一个接口有多个实现类，这些实现类都配置了 Bean，根据接口类型可以获取 Bean 吗？

> 不行，因为 Bean 不唯一

**结论**

根据类型来获取 Bean 时，在满足 Bean 唯一性的前提下，其实只是看：『对象 **instanceof** 指定的类型』的返回结果，只要返回的是 true 就可以认定为和类型匹配，能够获取到。

Java 中，instanceof 运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回 true，否则返回 false。也就是说：用 instanceof 关键字做判断时，instanceof 操作符的左右操作必须有继承或实现关系。


### 实验二：依赖注入之 setter 注入

创建学生类 Student

```java
package cn.youngkbt.Spring6.Bean;

public class Student {

    private Integer id;

    private String name;

    private Integer age;

    private String sex;

    public Student() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", sex='" + sex + '\'' +
                '}';
    }

}
```

配置 Bean 时为属性赋值

Spring-di.xml

```xml
<Bean id="studentOne" class="cn.youngkbt.Spring6.Bean.Student">
    <!-- property 标签：通过组件类的 setXxx() 方法给组件对象设置属性 -->
    <!-- name 属性：指定属性名（这个属性名是 getXxx()、setXxx() 方法定义的，和成员变量无关） -->
    <!-- value 属性：指定属性值 -->
    <property name="id" value="1001"></property>
    <property name="name" value="张三"></property>
    <property name="age" value="23"></property>
    <property name="sex" value="男"></property>
</Bean>
```

测试

```java
@Test
public void testDIBySet(){
    ApplicationContext ac = new ClassPathXmlApplicationContext("Spring-di.xml");
    Student studentOne = ac.getBean("studentOne", Student.class);
    System.out.println(studentOne);
}
```



### 实验三：依赖注入之构造器注入

在 Student 类中添加有参构造

```java
public Student(Integer id, String name, Integer age, String sex) {
    this.id = id;
    this.name = name;
    this.age = age;
    this.sex = sex;
}
```

配置 Bean

Spring-di.xml

```xml
<Bean id="studentTwo" class="cn.youngkbt.Spring6.Bean.Student">
    <constructor-arg value="1002"></constructor-arg>
    <constructor-arg value="李四"></constructor-arg>
    <constructor-arg value="33"></constructor-arg>
    <constructor-arg value="女"></constructor-arg>
</Bean>
```

> 注意：
>
> constructor-arg 标签还有两个属性可以进一步描述构造器参数：
>
> - index 属性：指定参数所在位置的索引（从 0 开始）
> - name 属性：指定参数名

测试

```java
@Test
public void testDIByConstructor(){
    ApplicationContext ac = new ClassPathXmlApplicationContext("Spring-di.xml");
    Student studentOne = ac.getBean("studentTwo", Student.class);
    System.out.println(studentOne);
}
```



### 实验四：特殊值处理

#### 字面量赋值

> 什么是字面量？
>
> int a = 10;
>
> 声明一个变量a，初始化为 10，此时 a 就不代表字母 a 了，而是作为一个变量的名字。当我们引用 a 的时候，我们实际上拿到的值是 10。
>
> 而如果 a 是带引号的：'a'，那么它现在不是一个变量，它就是代表 a 这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。

```xml
<!-- 使用 value 属性给 Bean 的属性赋值时，Spring 会把 value 属性的值看做字面量 -->
<property name="name" value="张三"/>
```

#### null值

```xml
<property name="name">
    <null />
</property>
```

> 注意：
>
> ```xml
> <property name="name" value="null"></property>
> ```
>
> 以上写法，为 name 所赋的值是字符串 null

#### xml 实体

```xml
<!-- 小于号在 XML 文档中用来定义标签的开始，不能随便使用 -->
<!-- 解决方案一：使用 XML 实体来代替 -->
<property name="expression" value="a &lt; b"/>
```

#### CDATA 节

```xml
<property name="expression">
    <!-- 解决方案二：使用 CDATA 节 -->
    <!-- CDATA 中的 C 代表 Character，是文本、字符的含义，CDATA 就表示纯文本数据 -->
    <!-- XML解析器看到 CDATA 节就知道这里是纯文本，就不会当作 XML 标签或属性来解析 -->
    <!-- 所以 CDATA 节中写什么符号都随意 -->
    <value><![CDATA[a < b]]></value>
</property>
```

### 实验五：为对象类型属性赋值

创建班级 类Clazz

```java
package cn.youngkbt.Spring6.Bean
    
public class Clazz {

    private Integer clazzId;

    private String clazzName;

    public Integer getClazzId() {
        return clazzId;
    }

    public void setClazzId(Integer clazzId) {
        this.clazzId = clazzId;
    }

    public String getClazzName() {
        return clazzName;
    }

    public void setClazzName(String clazzName) {
        this.clazzName = clazzName;
    }

    @Override
    public String toString() {
        return "Clazz{" +
                "clazzId=" + clazzId +
                ", clazzName='" + clazzName + '\'' +
                '}';
    }

    public Clazz() {
    }

    public Clazz(Integer clazzId, String clazzName) {
        this.clazzId = clazzId;
        this.clazzName = clazzName;
    }
}
```

修改 Student 类

在 Student 类中添加以下代码：

```java
private Clazz clazz;

public Clazz getClazz() {
	return clazz;
}

public void setClazz(Clazz clazz) {
	this.clazz = clazz;
}
```

#### 方式一：引用外部 Bean

配置 Clazz 类型的 Bean：

```xml
<Bean id="clazzOne" class="cn.youngkbt.Spring6.Bean.Clazz">
    <property name="clazzId" value="1111"></property>
    <property name="clazzName" value="财源滚滚班"></property>
</Bean>
```

为 Student 中的 clazz 属性赋值：

```xml
<Bean id="studentFour" class="cn.youngkbt.Spring6.Bean.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="sex" value="女"></property>
    <!-- ref 属性：引用XML容器中某个 Bean 的id，将所对应的 Bean 为属性赋值 -->
    <property name="clazz" ref="clazzOne"></property>
</Bean>
```

错误演示：

```xml
<Bean id="studentFour" class="cn.youngkbt.Spring6.Bean.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="sex" value="女"></property>
    <property name="clazz" value="clazzOne"></property>
</Bean>
```

如果错把 ref 属性写成了 value 属性，会抛出异常：

```java
Caused by: Java.lang.IllegalStateException: Cannot convert value of type 'Java.lang.String' to required type 'cn.youngkbt.Spring6.Bean.Clazz' for property 'clazz': no matching editors or conversion strategy found
```

意思是不能把 String 类型转换成我们要的 Clazz 类型，说明我们使用 value 属性时，Spring 只把这个属性看做一个普通的字符串，不会认为这是一个 Bean 的 id，更不会根据它去找到 Bean 来赋值。



#### 方式二：内部 Bean

```xml
<Bean id="studentFour" class="cn.youngkbt.Spring6.Bean.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="sex" value="女"></property>
    <property name="clazz">
        <!-- 在一个 Bean 中再声明一个 Bean 就是内部 Bean -->
        <!-- 内部 Bean 只能用于给属性赋值，不能在外部通过 XML 容器获取，因此可以省略 id 属性 -->
        <Bean id="clazzInner" class="cn.youngkbt.Spring6.Bean.Clazz">
            <property name="clazzId" value="2222"></property>
            <property name="clazzName" value="远大前程班"></property>
        </Bean>
    </property>
</Bean>
```

#### 方式三：级联属性赋值

```xml
<Bean id="studentFour" class="cn.youngkbt.Spring6.Bean.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="sex" value="女"></property>
    <property name="clazz" ref="clazzOne"></property>
    <property name="clazz.clazzId" value="3333"></property>
    <property name="clazz.clazzName" value="最强王者班"></property>
</Bean>
```



### 实验六：为数组类型属性赋值

修改Student类

在 Student 类中添加以下代码：

```java
private String[] hobbies;

public String[] getHobbies() {
    return hobbies;
}

public void setHobbies(String[] hobbies) {
    this.hobbies = hobbies;
}
```

配置 Bean

```xml
<Bean id="studentFour" class="cn.youngkbt.Spring.Bean6.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="sex" value="女"></property>
    <!-- ref属性：引用XML容器中某个Bean的id，将所对应的Bean为属性赋值 -->
    <property name="clazz" ref="clazzOne"></property>
    <property name="hobbies">
        <array>
            <value>抽烟</value>
            <value>喝酒</value>
            <value>烫头</value>
        </array>
    </property>
</Bean>
```



### 实验七：为集合类型属性赋值

#### 为List集合类型属性赋值

在 Clazz 类中添加以下代码：

```java
private List<Student> students;

public List<Student> getStudents() {
    return students;
}

public void setStudents(List<Student> students) {
    this.students = students;
}
```

配置 Bean：

```xml
<Bean id="clazzTwo" class="cn.youngkbt.Spring6.Bean.Clazz">
    <property name="clazzId" value="4444"></property>
    <property name="clazzName" value="Javaee0222"></property>
    <property name="students">
        <list>
            <ref Bean="studentOne"></ref>
            <ref Bean="studentTwo"></ref>
            <ref Bean="studentThree"></ref>
        </list>
    </property>
</Bean>
```

> 若为 Set 集合类型属性赋值，只需要将其中的 list 标签改为 set 标签即可

#### 为 Map 集合类型属性赋值

创建教师类 Teacher：

```java
package cn.youngkbt.Spring6.Bean;
public class Teacher {

    private Integer teacherId;

    private String teacherName;

    public Integer getTeacherId() {
        return teacherId;
    }

    public void setTeacherId(Integer teacherId) {
        this.teacherId = teacherId;
    }

    public String getTeacherName() {
        return teacherName;
    }

    public void setTeacherName(String teacherName) {
        this.teacherName = teacherName;
    }

    public Teacher(Integer teacherId, String teacherName) {
        this.teacherId = teacherId;
        this.teacherName = teacherName;
    }

    public Teacher() {

    }
    
    @Override
    public String toString() {
        return "Teacher{" +
                "teacherId=" + teacherId +
                ", teacherName='" + teacherName + '\'' +
                '}';
    }
}
```

在 Student 类中添加以下代码：

```java
private Map<String, Teacher> teacherMap;

public Map<String, Teacher> getTeacherMap() {
    return teacherMap;
}

public void setTeacherMap(Map<String, Teacher> teacherMap) {
    this.teacherMap = teacherMap;
}
```

配置 Bean：

```xml
<Bean id="teacherOne" class="cn.youngkbt.Spring6.Bean.Teacher">
    <property name="teacherId" value="10010"></property>
    <property name="teacherName" value="大宝"></property>
</Bean>

<Bean id="teacherTwo" class="cn.youngkbt.Spring6.Bean.Teacher">
    <property name="teacherId" value="10086"></property>
    <property name="teacherName" value="二宝"></property>
</Bean>

<Bean id="studentFour" class="cn.youngkbt.Spring6.Bean.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="sex" value="女"></property>
    <!-- ref 属性：引用 XML 容器中某个 Bean 的 id，将所对应的 Bean 为属性赋值 -->
    <property name="clazz" ref="clazzOne"></property>
    <property name="hobbies">
        <array>
            <value>抽烟</value>
            <value>喝酒</value>
            <value>烫头</value>
        </array>
    </property>
    <property name="teacherMap">
        <map>
            <entry>
                <key>
                    <value>10010</value>
                </key>
                <ref Bean="teacherOne"></ref>
            </entry>
            <entry>
                <key>
                    <value>10086</value>
                </key>
                <ref Bean="teacherTwo"></ref>
            </entry>
        </map>
    </property>
</Bean>
```

#### 引用集合类型的 Bean

```xml
<!--list 集合类型的 Bean-->
<util:list id="students">
    <ref Bean="studentOne"></ref>
    <ref Bean="studentTwo"></ref>
    <ref Bean="studentThree"></ref>
</util:list>
<!--map 集合类型的 Bean-->
<util:map id="teacherMap">
    <entry>
        <key>
            <value>10010</value>
        </key>
        <ref Bean="teacherOne"></ref>
    </entry>
    <entry>
        <key>
            <value>10086</value>
        </key>
        <ref Bean="teacherTwo"></ref>
    </entry>
</util:map>
<Bean id="clazzTwo" class="cn.youngkbt.Spring6.Bean.Clazz">
    <property name="clazzId" value="4444"></property>
    <property name="clazzName" value="Javaee0222"></property>
    <property name="students" ref="students"></property>
</Bean>
<Bean id="studentFour" class="cn.youngkbt.Spring6.Bean.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="sex" value="女"></property>
    <!-- ref 属性：引用 XML 容器中某个 Bean 的 id，将所对应的 Bean 为属性赋值 -->
    <property name="clazz" ref="clazzOne"></property>
    <property name="hobbies">
        <array>
            <value>抽烟</value>
            <value>喝酒</value>
            <value>烫头</value>
        </array>
    </property>
    <property name="teacherMap" ref="teacherMap"></property>
</Bean>
```

使用 `util:list`、`util:map` 标签必须引入相应的命名空间

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Beans xmlns="http://www.Springframework.org/schema/Beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:util="http://www.Springframework.org/schema/util"
    xsi:schemaLocation="http://www.Springframework.org/schema/util
    http://www.Springframework.org/schema/util/Spring-util.xsd
    http://www.Springframework.org/schema/Beans
    http://www.Springframework.org/schema/Beans/Spring-Beans.xsd">
```



### 实验八：p 命名空间

引入 p 命名空间

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Beans xmlns="http://www.Springframework.org/schema/Beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.Springframework.org/schema/util"
       xmlns:p="http://www.Springframework.org/schema/p"
       xsi:schemaLocation="http://www.Springframework.org/schema/util
       http://www.Springframework.org/schema/util/Spring-util.xsd
       http://www.Springframework.org/schema/Beans
       http://www.Springframework.org/schema/Beans/Spring-Beans.xsd">
```

引入 p 命名空间后，可以通过以下方式为 Bean 的各个属性赋值

```xml
<Bean id="studentSix" class="cn.youngkbt.Spring6.Bean.Student"
    p:id="1006" p:name="小明" p:clazz-ref="clazzOne" p:teacherMap-ref="teacherMap"></Bean>
```



### 实验九：引入外部属性文件

加入依赖

```xml
 <!-- MySQL 驱动 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-Java</artifactId>
    <version>8.0.30</version>
</dependency>

<!-- 数据源 -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.15</version>
</dependency>
```

创建外部属性文件

![images](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Spring6/20231027234057.png)

```properties
jdbc.user=root
jdbc.password=youngkbt
jdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC
jdbc.driver=com.mysql.cj.jdbc.Driver
```

**引入属性文件**

引入 context 名称空间

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Beans xmlns="http://www.Springframework.org/schema/Beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.Springframework.org/schema/context"
       xsi:schemaLocation="http://www.Springframework.org/schema/Beans
       http://www.Springframework.org/schema/Beans/Spring-Beans.xsd
       http://www.Springframework.org/schema/context
       http://www.Springframework.org/schema/context/Spring-context.xsd">

</Beans>
```

```xml
<!-- 引入外部属性文件 -->
<context:property-placeholder location="classpath:jdbc.properties"/>
```

注意：在使用 <context:property-placeholder> 元素加载外包配置文件功能前，首先需要在 XML 配置的一级标签 `<Beans>` 中添加 context 相关的约束。

配置 Bean

```xml
<Bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="url" value="${jdbc.url}"/>
    <property name="driverClassName" value="${jdbc.driver}"/>
    <property name="username" value="${jdbc.user}"/>
    <property name="password" value="${jdbc.password}"/>
</Bean>
```

测试

```java
@Test
public void testDataSource() throws SQLException {
    ApplicationContext ac = new ClassPathXmlApplicationContext("Spring-datasource.xml");
    DataSource dataSource = ac.getBean(DataSource.class);
    Connection connection = dataSource.getConnection();
    System.out.println(connection);
}
```



### 实验十：Bean 的作用域

概念

在 Spring 中可以通过配置 Bean 标签的 scope 属性来指定 Bean 的作用域范围，各取值含义参加下表：

| 取值              | 含义                                        | 创建对象的时机   |
| ----------------- | ------------------------------------------- | ---------------- |
| singleton（默认） | 在 XML 容器中，这个 Bean 的对象始终为单实例 | XML 容器初始化时 |
| prototype         | 这个 Bean 在 XML 容器中有多个实例           | 获取 Bean 时     |

如果是在 WebApplicationContext 环境下还会有另外几个作用域（但不常用）：

| 取值    | 含义                 |
| ------- | -------------------- |
| request | 在一个请求范围内有效 |
| session | 在一个会话范围内有效 |

创建类 User

```java
package cn.youngkbt.Spring6.Bean;
public class User {

    private Integer id;

    private String username;

    private String password;

    private Integer age;

    public User() {
    }

    public User(Integer id, String username, String password, Integer age) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.age = age;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", age=" + age +
                '}';
    }
}
```

配置 Bean

```xml
<!-- scope 属性：取值 singleton（默认值），Bean 在 XML 容器中只有一个实例，XML 容器初始化时创建对象 -->
<!-- scope 属性：取值 prototype，Bean 在 XML 容器中可以有多个实例，getBean() 时创建对象 -->
<Bean class="cn.youngkbt.Spring6.Bean.User" scope="prototype"></Bean>
```

测试

```java
@Test
public void testBeanScope(){
    ApplicationContext ac = new ClassPathXmlApplicationContext("Spring-scope.xml");
    User user1 = ac.getBean(User.class);
    User user2 = ac.getBean(User.class);
    System.out.println(user1==user2);
}
```



### 实验十一：Bean生命周期

具体的生命周期过程

- Bean 对象创建（调用无参构造器）

- 给 Bean 对象设置属性

- Bean 的后置处理器（初始化之前）

- Bean 对象初始化（需在配置 Bean 时指定初始化方法）

- Bean 的后置处理器（初始化之后）

- Bean 对象就绪可以使用

- Bean 对象销毁（需在配置Bean时指定销毁方法）

- XML容器关闭

修改类 User

```java
public class User {

    private Integer id;

    private String username;

    private String password;

    private Integer age;

    public User() {
        System.out.println("生命周期：1、创建对象");
    }

    public User(Integer id, String username, String password, Integer age) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.age = age;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        System.out.println("生命周期：2、依赖注入");
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public void initMethod(){
        System.out.println("生命周期：3、初始化");
    }

    public void destroyMethod(){
        System.out.println("生命周期：5、销毁");
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", age=" + age +
                '}';
    }
}
```

> 注意其中的 `initMethod()` 和 `destroyMethod()`，可以通过配置 Bean 指定为初始化和销毁的方法。

配置 Bean

```xml
<!-- 使用 init-method 属性指定初始化方法 -->
<!-- 使用 destroy-method 属性指定销毁方法 -->
<Bean class="cn.youngkbt.Spring6.Bean.User" scope="prototype" init-method="initMethod" destroy-method="destroyMethod">
    <property name="id" value="1001"></property>
    <property name="username" value="admin"></property>
    <property name="password" value="123456"></property>
    <property name="age" value="23"></property>
</Bean>
```

测试

```java
@Test
public void testLife(){
    ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("Spring-lifecycle.xml");
    User Bean = ac.getBean(User.class);
    System.out.println("生命周期：4、通过XML容器获取Bean并使用");
    ac.close();
}
```

Bean 的后置处理器

Bean 的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现 BeanPostProcessor 接口，且配置到 XML 容器中，需要注意的是，Bean 后置处理器不是单独针对某一个 Bean 生效，而是针对 XML 容器中所有 Bean 都会执行

创建 Bean 的后置处理器：

```java
package cn.youngkbt.Spring6.process;
    
import org.Springframework.Beans.BeansException;
import org.Springframework.Beans.factory.config.BeanPostProcessor;

public class MyBeanProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object Bean, String BeanName) throws BeansException {
        System.out.println("☆☆☆" + BeanName + " = " + Bean);
        return Bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(Object Bean, String BeanName) throws BeansException {
        System.out.println("★★★" + BeanName + " = " + Bean);
        return Bean;
    }
}
```

在 XML 容器中配置后置处理器：

```xml
<!-- Bean 的后置处理器要放入 XML 容器才能生效 -->
<Bean id="myBeanProcessor" class="cn.youngkbt.Spring6.process.MyBeanProcessor"/>
```



### 实验十二：FactoryBean

简介

FactoryBean 是 Spring 提供的一种整合第三方框架的常用机制。和普通的 Bean 不同，配置一个 FactoryBean 类型的 Bean，在获取 Bean 的时候得到的并不是 class 属性中配置的这个类的对象，而是 `getObject()` 方法的返回值。通过这种机制，Spring 可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。

将来我们整合 Mybatis 时，Spring 就是通过 FactoryBean 机制来帮我们创建 SqlSessionFactory 对象的。

```java
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.Springframework.Beans.factory;

import org.Springframework.lang.Nullable;

/**
 * Interface to be implemented by objects used within a {@link BeanFactory} which
 * are themselves factories for individual objects. If a Bean implements this
 * interface, it is used as a factory for an object to expose, not directly as a
 * Bean instance that will be exposed itself.
 *
 * <p><b>NB: A Bean that implements this interface cannot be used as a normal Bean.</b>
 * A FactoryBean is defined in a Bean style, but the object exposed for Bean
 * references ({@link #getObject()}) is always the object that it creates.
 *
 * <p>FactoryBeans can support singletons and prototypes, and can either create
 * objects lazily on demand or eagerly on startup. The {@link SmartFactoryBean}
 * interface allows for exposing more fine-grained behavioral metadata.
 *
 * <p>This interface is heavily used within the framework itself, for example for
 * the AOP {@link org.Springframework.aop.framework.ProxyFactoryBean} or the
 * {@link org.Springframework.jndi.JndiObjectFactoryBean}. It can be used for
 * custom components as well; however, this is only common for infrastructure code.
 *
 * <p><b>{@code FactoryBean} is a programmatic contract. Implementations are not
 * supposed to rely on annotation-driven injection or other reflective facilities.</b>
 * {@link #getObjectType()} {@link #getObject()} invocations may arrive early in the
 * bootstrap process, even ahead of any post-processor setup. If you need access to
 * other Beans, implement {@link BeanFactoryAware} and obtain them programmatically.
 *
 * <p><b>The container is only responsible for managing the lifecycle of the FactoryBean
 * instance, not the lifecycle of the objects created by the FactoryBean.</b> Therefore,
 * a destroy method on an exposed Bean object (such as {@link Java.io.Closeable#close()}
 * will <i>not</i> be called automatically. Instead, a FactoryBean should implement
 * {@link DisposableBean} and delegate any such close call to the underlying object.
 *
 * <p>Finally, FactoryBean objects participate in the containing BeanFactory's
 * synchronization of Bean creation. There is usually no need for internal
 * synchronization other than for purposes of lazy initialization within the
 * FactoryBean itself (or the like).
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @since 08.03.2003
 * @param <T> the Bean type
 * @see org.Springframework.Beans.factory.BeanFactory
 * @see org.Springframework.aop.framework.ProxyFactoryBean
 * @see org.Springframework.jndi.JndiObjectFactoryBean
 */
public interface FactoryBean<T> {

    /**
     * The name of an attribute that can be
     * {@link org.Springframework.core.AttributeAccessor#setAttribute set} on a
     * {@link org.Springframework.Beans.factory.config.BeanDefinition} so that
     * factory Beans can signal their object type when it can't be deduced from
     * the factory Bean class.
     * @since 5.2
     */
    String OBJECT_TYPE_ATTRIBUTE = "factoryBeanObjectType";

    /**
     * Return an instance (possibly shared or independent) of the object
     * managed by this factory.
     * <p>As with a {@link BeanFactory}, this allows support for both the
     * Singleton and Prototype design pattern.
     * <p>If this FactoryBean is not fully initialized yet at the time of
     * the call (for example because it is involved in a circular reference),
     * throw a corresponding {@link FactoryBeanNotInitializedException}.
     * <p>As of Spring 2.0, FactoryBeans are allowed to return {@code null}
     * objects. The factory will consider this as normal value to be used; it
     * will not throw a FactoryBeanNotInitializedException in this case anymore.
     * FactoryBean implementations are encouraged to throw
     * FactoryBeanNotInitializedException themselves now, as appropriate.
     * @return an instance of the Bean (can be {@code null})
     * @throws Exception in case of creation errors
     * @see FactoryBeanNotInitializedException
     */
    @Nullable
    T getObject() throws Exception;

    /**
     * Return the type of object that this FactoryBean creates,
     * or {@code null} if not known in advance.
     * <p>This allows one to check for specific types of Beans without
     * instantiating objects, for example on autowiring.
     * <p>In the case of implementations that are creating a singleton object,
     * this method should try to avoid singleton creation as far as possible;
     * it should rather estimate the type in advance.
     * For prototypes, returning a meaningful type here is advisable too.
     * <p>This method can be called <i>before</i> this FactoryBean has
     * been fully initialized. It must not rely on state created during
     * initialization; of course, it can still use such state if available.
     * <p><b>NOTE:</b> Autowiring will simply ignore FactoryBeans that return
     * {@code null} here. Therefore it is highly recommended to implement
     * this method properly, using the current state of the FactoryBean.
     * @return the type of object that this FactoryBean creates,
     * or {@code null} if not known at the time of the call
     * @see ListableBeanFactory#getBeansOfType
     */
    @Nullable
    Class<?> getObjectType();

    /**
     * Is the object managed by this factory a singleton? That is,
     * will {@link #getObject()} always return the same object
     * (a reference that can be cached)?
     * <p><b>NOTE:</b> If a FactoryBean indicates to hold a singleton object,
     * the object returned from {@code getObject()} might get cached
     * by the owning BeanFactory. Hence, do not return {@code true}
     * unless the FactoryBean always exposes the same reference.
     * <p>The singleton status of the FactoryBean itself will generally
     * be provided by the owning BeanFactory; usually, it has to be
     * defined as singleton there.
     * <p><b>NOTE:</b> This method returning {@code false} does not
     * necessarily indicate that returned objects are independent instances.
     * An implementation of the extended {@link SmartFactoryBean} interface
     * may explicitly indicate independent instances through its
     * {@link SmartFactoryBean#isPrototype()} method. Plain {@link FactoryBean}
     * implementations which do not implement this extended interface are
     * simply assumed to always return independent instances if the
     * {@code isSingleton()} implementation returns {@code false}.
     * <p>The default implementation returns {@code true}, since a
     * {@code FactoryBean} typically manages a singleton instance.
     * @return whether the exposed object is a singleton
     * @see #getObject()
     * @see SmartFactoryBean#isPrototype()
     */
    default boolean isSingleton() {
        return true;
    }
}
```

创建类 UserFactoryBean

```java
package cn.youngkbt.Spring6.Bean;
public class UserFactoryBean implements FactoryBean<User> {
    @Override
    public User getObject() throws Exception {
        return new User();
    }

    @Override
    public Class<?> getObjectType() {
        return User.class;
    }
}
```

配置 Bean

```xml
<Bean id="user" class="cn.youngkbt.Spring6.Bean.UserFactoryBean"></Bean>
```

测试

```java
@Test
public void testUserFactoryBean(){
    // 获取 XML 容器
    ApplicationContext ac = new ClassPathXmlApplicationContext("Spring-factoryBean.xml");
    User user = (User) ac.getBean("user");
    System.out.println(user);
}
```



### 实验十三：基于 XML 自动装配

> 自动装配：
>
> 根据指定的策略，在 XML 容器中匹配某一个 Bean，自动为指定的 Bean 中所依赖的类类型或接口类型属性赋值

场景模拟

创建类 UserController

```java
package cn.youngkbt.Spring6.autowire.controller
public class UserController {

    private UserService userService;

    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public void saveUser(){
        userService.saveUser();
    }

}
```

创建接口 UserService

```java
package cn.youngkbt.Spring6.autowire.service
public interface UserService {

    void saveUser();

}
```

创建类 UserServiceImpl 实现接口 UserService

```java
package cn.youngkbt.Spring6.autowire.service.impl
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void saveUser() {
        userDao.saveUser();
    }

}
```

创建接口 UserDao

```java
package cn.youngkbt.Spring6.autowire.dao
public interface UserDao {

    void saveUser();

}
```

创建类 UserDaoImpl 实现接口 UserDao

```java
package cn.youngkbt.Spring6.autowire.dao.impl
public class UserDaoImpl implements UserDao {

    @Override
    public void saveUser() {
        System.out.println("保存成功");
    }

}
```

配置Bean

> 使用 Bean 标签的 autowire 属性设置自动装配效果
>
> 自动装配方式：byType
>
> byType：根据类型匹配XML容器中的某个兼容类型的 Bean，为属性自动赋值
>
> 若在 XML 中，没有任何一个兼容类型的 Bean 能够为属性赋值，则该属性不装配，即值为默认值 null
>
> 若在 XML 中，有多个兼容类型的 Bean 能够为属性赋值，则抛出异常 NoUniqueBeanDefinitionException

```xml
<Bean id="userController" class="cn.youngkbt.Spring6.autowire.controller.UserController" autowire="byType"></Bean>

<Bean id="userService" class="cn.youngkbt.Spring6.autowire.service.impl.UserServiceImpl" autowire="byType"></Bean>

<Bean id="userDao" class="cn.youngkbt.Spring6.autowire.dao.impl.UserDaoImpl"></Bean>
```

> 自动装配方式：byName
>
> byName：将自动装配的属性的属性名，作为 Bean 的 id 在 XML 容器中匹配相对应的 Bean 进行赋值

```xml
<Bean id="userController" class="cn.youngkbt.Spring6.autowire.controller.UserController" autowire="byName"></Bean>

<Bean id="userService" class="cn.youngkbt.Spring6.autowire.service.impl.UserServiceImpl" autowire="byName"></Bean>
<Bean id="userServiceImpl" class="cn.youngkbt.Spring6.autowire.service.impl.UserServiceImpl" autowire="byName"></Bean>

<Bean id="userDao" class="cn.youngkbt.Spring6.autowire.dao.impl.UserDaoImpl"></Bean>
<Bean id="userDaoImpl" class="cn.youngkbt.Spring6.autowire.dao.impl.UserDaoImpl"></Bean>
```

测试

```java
@Test
public void testAutoWireByXML(){
    ApplicationContext ac = new ClassPathXmlApplicationContext("autowire-xml.xml");
    UserController userController = ac.getBean(UserController.class);
    userController.saveUser();
}
```



## 基于注解管理 Bean

从 Java 5 开始，Java 增加了对注解（Annotation）的支持，它是代码中的一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理。开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。

Spring 从 2.5 版本开始提供了对注解技术的全面支持，我们可以使用注解来实现自动装配，简化 Spring 的 XML 配置。

Spring 通过注解实现自动装配的步骤如下：

1. 引入依赖
2. 开启组件扫描
3. 使用注解定义 Bean
4. 依赖注入

### 搭建子模块

搭建方式如：Spring6-XML-xml。

引入配置文件 Spring-XML-xml 模块日志 log4j2.xml。

添加依赖

```xml
<dependencies>
    <!--Spring context 依赖-->
    <!--当你引入 Spring Context 依赖之后，表示将 Spring 的基础依赖引入了-->
    <dependency>
        <groupId>org.Springframework</groupId>
        <artifactId>Spring-context</artifactId>
        <version>6.0.3</version>
    </dependency>

    <!--junit5 测试-->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId>
    </dependency>

    <!--log4j2 的依赖-->
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>2.19.0</version>
    </dependency>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-slf4j2-impl</artifactId>
        <version>2.19.0</version>
    </dependency>
</dependencies>
```

### 开启组件扫描

Spring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 <context:component-scan> 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Beans xmlns="http://www.Springframework.org/schema/Beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.Springframework.org/schema/context"
       xsi:schemaLocation="http://www.Springframework.org/schema/Beans
    http://www.Springframework.org/schema/Beans/Spring-Beans-3.0.xsd
    http://www.Springframework.org/schema/context
            http://www.Springframework.org/schema/context/Spring-context.xsd">
    <!--开启组件扫描功能-->
    <context:component-scan base-package="cn.youngkbt.Spring6"></context:component-scan>
</Beans>
```

注意：在使用 <context:component-scan> 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 `<Beans>` 中添加 context 相关的约束。

情况一：最基本的扫描方式

```xml
<context:component-scan base-package="cn.youngkbt.Spring6">
</context:component-scan>
```

情况二：指定要排除的组件

```xml
<context:component-scan base-package="cn.youngkbt.Spring6">
    <!-- context:exclude-filter 标签：指定排除规则 -->
    <!-- 
 		type：设置排除或包含的依据
		type="annotation"，根据注解排除，expression 中设置要排除的注解的全类名
		type="assignable"，根据类型排除，expression 中设置要排除的类型的全类名
	-->
    <context:exclude-filter type="annotation" expression="org.Springframework.stereotype.Controller"/>
        <!--<context:exclude-filter type="assignable" expression="cn.youngkbt.Spring6.controller.UserController"/>-->
</context:component-scan>
```

情况三：仅扫描指定组件

```xml
<context:component-scan base-package="cn.youngkbt" use-default-filters="false">
    <!-- context:include-filter 标签：指定在原有扫描规则的基础上追加的规则 -->
    <!-- use-default-filters 属性：取值 false 表示关闭默认扫描规则 -->
    <!-- 此时必须设置 use-default-filters="false"，因为默认规则即扫描指定包下所有类 -->
    <!-- 
 		type：设置排除或包含的依据
		type="annotation"，根据注解排除，expression 中设置要排除的注解的全类名
		type="assignable"，根据类型排除，expression 中设置要排除的类型的全类名
	-->
    <context:include-filter type="annotation" expression="org.Springframework.stereotype.Controller"/>
	<!--<context:include-filter type="assignable" expression="cn.youngkbt.Spring6.controller.UserController"/>-->
</context:component-scan>
```



### 使用注解定义 Bean

Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。

| 注解        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| @Component  | 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。  使用时只需将该注解标注在相应类上即可。 |
| @Repository | 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 `@Component` 相同。 |
| @Service    | 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 |
| @Controller | 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 `@Component` 相同。 |



### 实验一：@Autowired注入

单独使用 `@Autowired` 注解，**默认根据类型装配**。【默认是 byType】

查看源码：

```java
package org.Springframework.Beans.factory.annotation;

import Java.lang.annotation.Documented;
import Java.lang.annotation.ElementType;
import Java.lang.annotation.Retention;
import Java.lang.annotation.RetentionPolicy;
import Java.lang.annotation.Target;

@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {
    boolean required() default true;
}
```

源码中有两处需要注意：

- 第一处：该注解可以标注在哪里？

- - 构造方法上
  - 方法上
  - 形参上
  - 属性上
  - 注解上

- 第二处：该注解有一个 required 属性，默认值是 true，表示在注入的时候要求被注入的 Bean 必须是存在的，如果不存在则报错。如果 required 属性设置为 false，表示注入的 Bean 存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。

#### 场景一：属性注入

创建 UserDao 接口

```java
package cn.youngkbt.Spring6.dao;

public interface UserDao {

    public void print();
}
```

创建 UserDaoImpl 实现

```java
package cn.youngkbt.Spring6.dao.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import org.Springframework.stereotype.Repository;

@Repository
public class UserDaoImpl implements UserDao {

    @Override
    public void print() {
        System.out.println("Dao层执行结束");
    }
}
```

创建 UserService 接口

```java
package cn.youngkbt.Spring6.service;

public interface UserService {

    public void out();
}
```

创建 UserServiceImpl 实现类

```java
package cn.youngkbt.Spring6.service.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import cn.youngkbt.Spring6.service.UserService;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Override
    public void out() {
        userDao.print();
        System.out.println("Service层执行结束");
    }
}
```

创建 UserController 类

```java
package cn.youngkbt.Spring6.controller;

import cn.youngkbt.Spring6.service.UserService;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.stereotype.Controller;

@Controller
public class UserController {

    @Autowired
    private UserService userService;

    public void out() {
        userService.out();
        System.out.println("Controller层执行结束。");
    }

}
```

测试一

```java
package cn.youngkbt.Spring6.Bean;

import cn.youngkbt.Spring6.controller.UserController;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.Springframework.context.ApplicationContext;
import org.Springframework.context.support.ClassPathXmlApplicationContext;

public class UserTest {

    private Logger logger = LoggerFactory.getLogger(UserTest.class);

    @Test
    public void testAnnotation(){
        ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
        UserController userController = context.getBean("userController", UserController.class);
        userController.out();
        logger.info("执行成功");
    }


}
```

测试结果：

![image-20221101153556681](https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/img/Spring6/20231027234734.png)

以上构造方法和 setter 方法都没有提供，经过测试，仍然可以注入成功。

####  场景二：set 注入

修改 UserServiceImpl 类

```java
package cn.youngkbt.Spring6.service.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import cn.youngkbt.Spring6.service.UserService;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    @Autowired
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void out() {
        userDao.print();
        System.out.println("Service层执行结束");
    }
}
```

修改 UserController 类

```java
package cn.youngkbt.Spring6.controller;

import cn.youngkbt.Spring6.service.UserService;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.stereotype.Controller;

@Controller
public class UserController {

    private UserService userService;

    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public void out() {
        userService.out();
        System.out.println("Controller层执行结束。");
    }

}
```

测试：成功调用

#### 场景三：构造方法注入

修改 UserServiceImpl 类

```java
package cn.youngkbt.Spring6.service.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import cn.youngkbt.Spring6.service.UserService;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    @Autowired
    public UserServiceImpl(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void out() {
        userDao.print();
        System.out.println("Service层执行结束");
    }
}
```

修改 UserController 类

```java
package cn.youngkbt.Spring6.controller;

import cn.youngkbt.Spring6.service.UserService;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.stereotype.Controller;

@Controller
public class UserController {

    private UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }

    public void out() {
        userService.out();
        System.out.println("Controller层执行结束。");
    }

}
```

测试：成功调用

#### 场景四：形参上注入

修改 UserServiceImpl 类

```java
package cn.youngkbt.Spring6.service.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import cn.youngkbt.Spring6.service.UserService;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public UserServiceImpl(@Autowired UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void out() {
        userDao.print();
        System.out.println("Service层执行结束");
    }
}
```

修改 UserController 类

```java
package cn.youngkbt.Spring6.controller;

import cn.youngkbt.Spring6.service.UserService;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.stereotype.Controller;

@Controller
public class UserController {

    private UserService userService;

    public UserController(@Autowired UserService userService) {
        this.userService = userService;
    }

    public void out() {
        userService.out();
        System.out.println("Controller层执行结束。");
    }

}
```

测试：成功调用

#### 场景五：只有一个构造函数，无注解

修改 UserServiceImpl 类

```java
package cn.youngkbt.Spring6.service.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import cn.youngkbt.Spring6.service.UserService;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.Beans.factory.annotation.Qualifier;
import org.Springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public UserServiceImpl(UserDao userDao) {
        this.userDao = userDao;
    }

    @Override
    public void out() {
        userDao.print();
        System.out.println("Service层执行结束");
    }
}
```

测试通过

**当有参数的构造方法只有一个时，@Autowired 注解可以省略。**

说明：有多个构造方法时呢？大家可以测试（再添加一个无参构造函数），测试报错。

#### 场景六：@Autowired 注解和 @Qualifier 注解联合

添加 dao 层实现

```java
package cn.youngkbt.Spring6.dao.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import org.Springframework.stereotype.Repository;

@Repository
public class UserDaoRedisImpl implements UserDao {

    @Override
    public void print() {
        System.out.println("Redis Dao层执行结束");
    }
}
```

测试：测试异常

错误信息中说：不能装配，UserDao 这个 Bean 的数量等于 2

怎么解决这个问题呢？**当然要 byName，根据名称进行装配了**。

修改 UserServiceImpl 类

```java
package cn.youngkbt.Spring6.service.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import cn.youngkbt.Spring6.service.UserService;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    @Autowired
    @Qualifier("userDaoImpl") // 指定 Bean 的名字
    private UserDao userDao;

    @Override
    public void out() {
        userDao.print();
        System.out.println("Service层执行结束");
    }
}
```

**总结**

- `@Autowired` 注解可以出现在：属性上、构造方法上、构造方法的参数上、setter 方法上
- 当带参数的构造方法只有一个，`@Autowired` 注解可以省略
- `@Autowired` 注解默认根据类型注入。如果要根据名称注入的话，需要配合 `@Qualifier` 注解一起使用



### 实验二：@Resource 注入

`@Resource` 注解也可以完成属性注入。那它和 `@Autowired` 注解有什么区别？

- `@Resource` 注解是 JDK 扩展包中的，也就是说属于 JDK 的一部分。所以该注解是标准注解，更加具有通用性(JSR-250 标准中制定的注解类型。JSR 是 Java 规范提案。)
- `@Autowired` 注解是 Spring 框架自己的
- **`@Resource` 注解默认根据名称装配 byName，未指定 name 时，使用属性名作为 name。通过 name 找不到的话会自动启动通过类型 byType 装配**
- **`@Autowired` 注解默认根据类型装配 byType，如果想根据名称装配，需要配合 `@Qualifier` 注解一起用**
- `@Resource` 注解用在属性上、setter 方法上。
- `@Autowired` 注解用在属性上、setter 方法上、构造方法上、构造方法参数上。

`@Resource` 注解属于 JDK 扩展包，所以不在 JDK 当中，需要额外引入以下依赖：【**如果是 JDK8 的话不需要额外引入依赖。高于 JDK11 或低于 JDK8 需要引入以下依赖**】

```xml
<dependency>
    <groupId>jakarta.annotation</groupId>
    <artifactId>jakarta.annotation-api</artifactId>
    <version>2.1.1</version> <!-- 版本根据需求填写 -->
</dependency>
```

源码：

```java
package jakarta.annotation;

import Java.lang.annotation.ElementType;
import Java.lang.annotation.Repeatable;
import Java.lang.annotation.Retention;
import Java.lang.annotation.RetentionPolicy;
import Java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(Resources.class)
public @interface Resource {
    String name() default "";

    String lookup() default "";

    Class<?> type() default Object.class;

    Resource.AuthenticationType authenticationType() default Resource.AuthenticationType.CONTAINER;

    boolean shareable() default true;

    String mappedName() default "";

    String description() default "";

    public static enum AuthenticationType {
        CONTAINER,
        APPLICATION;

        private AuthenticationType() {
        }
    }
}
```

#### 场景一：根据 name 注入

修改 UserDaoImpl 类

```java
package cn.youngkbt.Spring6.dao.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import org.Springframework.stereotype.Repository;

@Repository("myUserDao")
public class UserDaoImpl implements UserDao {

    @Override
    public void print() {
        System.out.println("Dao层执行结束");
    }
}
```

修改 UserServiceImpl 类

```java
package cn.youngkbt.Spring6.service.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import cn.youngkbt.Spring6.service.UserService;
import jakarta.annotation.Resource;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.Beans.factory.annotation.Qualifier;
import org.Springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    @Resource(name = "myUserDao")
    private UserDao myUserDao;

    @Override
    public void out() {
        myUserDao.print();
        System.out.println("Service层执行结束");
    }
}
```

测试通过

#### 场景二：name 未知注入

修改 UserDaoImpl 类

```java
package cn.youngkbt.Spring6.dao.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import org.Springframework.stereotype.Repository;

@Repository("myUserDao")
public class UserDaoImpl implements UserDao {

    @Override
    public void print() {
        System.out.println("Dao层执行结束");
    }
}
```

修改 UserServiceImpl 类

```java
package cn.youngkbt.Spring6.service.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import cn.youngkbt.Spring6.service.UserService;
import jakarta.annotation.Resource;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.Beans.factory.annotation.Qualifier;
import org.Springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    @Resource
    private UserDao myUserDao;

    @Override
    public void out() {
        myUserDao.print();
        System.out.println("Service层执行结束");
    }
}
```

测试通过

当 `@Resource` 注解使用时没有指定 name 的时候，还是根据 name 进行查找，这个 name 是属性名。

#### 场景三 其他情况

修改 UserServiceImp l类，userDao1 属性名不存在

```java
package cn.youngkbt.Spring6.service.impl;

import cn.youngkbt.Spring6.dao.UserDao;
import cn.youngkbt.Spring6.service.UserService;
import jakarta.annotation.Resource;
import org.Springframework.Beans.factory.annotation.Autowired;
import org.Springframework.Beans.factory.annotation.Qualifier;
import org.Springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    @Resource
    private UserDao userDao1;

    @Override
    public void out() {
        userDao1.print();
        System.out.println("Service层执行结束");
    }
}
```

测试异常

根据异常信息得知：显然当通过 name 找不到的时候，自然会启动 byType 进行注入，以上的错误是因为 UserDao 接口下有两个实现类导致的。所以根据类型注入就会报错。

`@Resource` 的s et 注入可以自行测试

> 总结
>

`@Resource` 注解：默认 byName 注入，没有指定 name 时把属性名当做 name，根据 name 找不到时，才会 byType 注入。byType 注入时，某种类型的 Bean 只能有一个。

### Spring 全注解开发

全注解开发就是不再使用 Spring 配置文件了，写一个配置类来代替配置文件。

```java
package cn.youngkbt.Spring6.config;

import org.Springframework.context.annotation.ComponentScan;
import org.Springframework.context.annotation.Configuration;

@Configuration
//@ComponentScan({"cn.youngkbt.Spring6.controller", "cn.youngkbt.Spring6.service","cn.youngkbt.Spring6.dao"})
@ComponentScan("cn.youngkbt.Spring6")
public class Spring6Config {
}
```

测试类

```java
@Test
public void testAllAnnotation(){
    ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class);
    UserController userController = context.getBean("userController", UserController.class);
    userController.out();
    logger.info("执行成功");
}
```

