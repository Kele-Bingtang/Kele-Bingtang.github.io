---
title: Redis - Java整合
date: 2021-12-26 16:01:49
permalink: /redis/java/
categories: 
  - Redis
tags: 
  - 缓存数据库
---

::: note

作为 Java 开发人员，我们不可能直接在命令行手动添加数据。而是需要利用 Java 来添加数据。

::: right

2021-12-26 @Young Kbt

:::

[[TOC]]

## Jedis

Jedis 是 Redis 官方推荐的 Java 连接开发工具。要在 Java 开发中使用好 Redis 中间件，必须对 Jedis 熟悉才能写成漂亮的代码。

### 测试ping

前提打开了 Redis 服务，否则 Java 无法连接 Redis 服务。

1、新建一个普通的 Maven 项目

2、导入 Redis 的依赖，版本自己选择

```xml
<dependencies>
    <!-- https://mvnrepository.com/artifact/redis.clients/jedis -->
    <dependency>
        <groupId>redis.clients</groupId>
        <artifactId>jedis</artifactId>
        <version>3.5.2</version>
    </dependency>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>fastjson</artifactId>
        <version>1.2.75</version>
    </dependency>
</dependencies>
```

3、编写测试代码，添加 Redis 服务所在的 IP 和 端口

```java
public class Ping {
    public static void main(String[] args) {
        // 添加 Redis 服务所在的 IP 和 端口
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        // 查看服务是否运行
        System.out.println(jedis.ping());
    }
}
```

### 常用API

Jedis 提供的 API 其实和我们之前敲的命令名几乎一模一样。

基本操作

```java
public static void main(String[] args) {
    Jedis jedis = new Jedis("127.0.0.1", 6379);

    // 验证密码，如果没有设置密码这段代码省略
    // jedis.auth("password");

    jedis.connect(); 		// 连接
    jedis.disconnect(); 	// 断开连接
    jedis.flushAll(); 		// 清空所有的key
}
```

对 key 操作的命令

```java
public class TestKey {
    public static void main(String[] args) {
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        
        System.out.println("清空数据：" + jedis.flushDB());
        System.out.println("判断某个键是否存在：" + jedis.exists("username"));
        System.out.println("新增 <'username','kele'> 的键值对：" + jedis.set("username", "kele"));
        System.out.println("新增 <'password','kele1234'> 的键值对：" + jedis.set("password", "kele1234"));

        System.out.print("系统中所有的键如下：");
        Set<String> keys = jedis.keys("*");
        System.out.println(keys);

        System.out.println("删除键 password:" + jedis.del("password"));
        System.out.println("判断键 password 是否存在：" + jedis.exists("password"));
        System.out.println("查看键 username 所存储的值的类型：" + jedis.type("username"));
        System.out.println("随机返回 key 空间的一个：" + jedis.randomKey());
        System.out.println("重命名 key：" + jedis.rename("username", "name"));
        System.out.println("取出改后的 name：" + jedis.get("name"));
        System.out.println("按索引查询：" + jedis.select(0));
        System.out.println("删除当前选择数据库中的所有 key：" + jedis.flushDB());
        System.out.println("返回当前数据库中 key 的数目：" + jedis.dbSize());
        System.out.println("删除所有数据库中的所有 key：" + jedis.flushAll());
    }
}
```

对 String 操作的命令

```java
public class TestString {
    public static void main(String[] args) {
        Jedis jedis = new Jedis("127.0.0.1", 6379);

        jedis.flushDB();
        
        System.out.println("=========== 增加数据开始 ===========");
        System.out.println(jedis.set("key1", "value1"));
        System.out.println(jedis.set("key2", "value2"));
        System.out.println(jedis.set("key3", "value3"));

        System.out.println("删除键 key2:" + jedis.del("key2"));
        System.out.println("获取键 key2:" + jedis.get("key2"));
        System.out.println("修改 key1:" + jedis.set("key1", "newValue1"));
        System.out.println("获取 key1 的值：" + jedis.get("key1"));
        System.out.println("在 key3 后面加入值：" + jedis.append("key3", "key4"));
        System.out.println("key3 的值：" + jedis.get("key3"));
        System.out.println("增加多个键值对：" + jedis.mset("key01", "value01", "key02", "value02", "key03", "value03"));
        System.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03"));
        System.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03", "key04"));
        System.out.println("删除多个键值对：" + jedis.del("key01", "key02"));
        System.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03"));
        System.out.println("=========== 增加数据结束 ===========");

        jedis.flushDB();

        System.out.println("=========== 新增键值对防止覆盖原先值开始 ==============");
        System.out.println(jedis.setnx("key1", "value1"));
        System.out.println(jedis.setnx("key2", "value2"));
        System.out.println(jedis.setnx("key2", "value2-new"));
        System.out.println(jedis.get("key1"));
        System.out.println(jedis.get("key2"));
        System.out.println("=========== 新增键值对防止覆盖原先值结束 ==============");
        
        System.out.println("=========== 新增键值对并设置有效时间开始 =============");
        System.out.println(jedis.setex("key3", 2, "value3"));
        System.out.println(jedis.get("key3"));
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(jedis.get("key3"));
        System.out.println("=========== 新增键值对并设置有效时间结束 =============");
        
        System.out.println("=========== 获取原值，更新为新值开始 ==========");
        System.out.println(jedis.getSet("key2", "key2GetSet"));
        System.out.println(jedis.get("key2"));
        System.out.println("获得 key2 的值的字串：" + jedis.getrange("key2", 2,4));
        System.out.println("=========== 获取原值，更新为新值结束 ==========");

    }
}
```

对 List 操作命令

```java
public class TestList {
    public static void main(String[] args) {
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        jedis.flushDB();
        
        System.out.println("===========添加一个 list===========");
        jedis.lpush("collections", "ArrayList", "Vector", "Stack", "HashMap", "WeakHashMap", "LinkedHashMap");
        jedis.lpush("collections", "HashSet");
        jedis.lpush("collections", "TreeSet");
        jedis.lpush("collections", "TreeMap");
        //-1 代表倒数第一个元素，-2 代表倒数第二个元素，end 为 -1 表示查询全部
        System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));
        System.out.println("collections 区间 0-3 的元素：" + jedis.lrange("collections", 0, 3));
        
        System.out.println("===============================");
        // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后 add 进去的值先被删，类似于出栈
        System.out.println("删除指定元素个数：" + jedis.lrem("collections", 2, "HashMap"));
        System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));
        System.out.println("删除下表 0-3 区间之外的元素：" + jedis.ltrim("collections", 0, 3));
        System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));
        System.out.println("collections 列表出栈（左端）：" + jedis.lpop("collections"));
        System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));
        System.out.println("collections 添加元素，从列表右端，与 lpush 相对应：" + jedis.rpush("collections", "EnumMap"));
        System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));
        System.out.println("collections 列表出栈（右端）：" + jedis.rpop("collections"));
        System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));
        System.out.println("修改 collections 指定下标 1 的内容：" + jedis.lset("collections", 1, "LinkedArrayList"));
        System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));
        
        System.out.println("===============================");
        System.out.println("collections 的长度：" + jedis.llen("collections"));
        System.out.println("获取 collections 下标为 2 的元素：" + jedis.lindex("collections", 2));
        
        System.out.println("===============================");
        jedis.lpush("sortedList", "3", "6", "2", "0", "7", "4");
        System.out.println("sortedList 排序前：" + jedis.lrange("sortedList", 0, -1));
        System.out.println(jedis.sort("sortedList"));
        System.out.println("sortedList 排序后：" + jedis.lrange("sortedList", 0, -1));
    }
}
```

对 Set 的操作命令

```java
public class TestSet {
    public static void main(String[] args) {
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        jedis.flushDB();
        
        System.out.println("============向集合中添加元素（不重复）============");
        System.out.println(jedis.sadd("eleSet", "e1", "e2", "e4", "e3", "e0", "e8", "e7", "e5"));
        System.out.println(jedis.sadd("eleSet", "e6"));
        System.out.println(jedis.sadd("eleSet", "e6"));
        System.out.println("eleSet 的所有元素为：" + jedis.smembers("eleSet"));
        System.out.println("删除一个元素 e0：" + jedis.srem("eleSet", "e0"));

        System.out.println("eleSet 的所有元素为：" + jedis.smembers("eleSet"));
        System.out.println("删除两个元素 e7 和 e6：" + jedis.srem("eleSet", "e7", "e6"));
        System.out.println("eleSet 的所有元素为：" + jedis.smembers("eleSet"));
        System.out.println("随机的移除集合中的一个元素：" + jedis.spop("eleSet"));
        System.out.println("随机的移除集合中的一个元素：" + jedis.spop("eleSet"));
        System.out.println("eleSet 的所有元素为：" + jedis.smembers("eleSet"));
        System.out.println("eleSet 中包含元素的个数：" + jedis.scard("eleSet"));
        System.out.println("e3 是否在 eleSet 中：" + jedis.sismember("eleSet", "e3"));
        System.out.println("e1 是否在 eleSet 中：" + jedis.sismember("eleSet", "e1"));
        System.out.println("e1 是否在 eleSet 中：" + jedis.sismember("eleSet", "e5"));
        
        System.out.println("=================================");
        System.out.println(jedis.sadd("eleSet1", "e1", "e2", "e4", "e3", "e0", "e8", "e7", "e5"));
        System.out.println(jedis.sadd("eleSet2","e1", "e2", "e4", "e3", "e0", "e8"));
        // 移到集合元素
        System.out.println("将 eleSet1 中删除 e1 并存入 eleSet3 中：" + jedis.smove("eleSet1", "eleSet3", "e1"));
        System.out.println("将 eleSet1 中删除 e2 并存入 eleSet3 中：" + jedis.smove("eleSet1", "eleSet3", "e2"));
        System.out.println("eleSet1 中的元素：" + jedis.smembers("eleSet1"));
        System.out.println("eleSet3 中的元素：" + jedis.smembers("eleSet3"));
        
        System.out.println("============集合运算=================");
        System.out.println("eleSet1 中的元素：" + jedis.smembers("eleSet1"));
        System.out.println("eleSet2 中的元素：" + jedis.smembers("eleSet2"));
        System.out.println("eleSet1 和 eleSet2 的交集:" + jedis.sinter("eleSet1", "eleSet2"));
        System.out.println("eleSet1 和 eleSet2 的并集:" + jedis.sunion("eleSet1", "eleSet2"));
        // eleSet1 中有，eleSet2 中没有
        System.out.println("eleSet1和eleSet2的差集:" + jedis.sdiff("eleSet1", "eleSet2"));
        // 求交集并将交集保存到 dstkey 的集合
        jedis.sinterstore("eleSet4", "eleSet1", "eleSet2");
        System.out.println("eleSet4 中的元素：" + jedis.smembers("eleSet4"));
    }
}
```

对 Hash 的操作命令

```java
public class TestHash {
    public static void main(String[] args) {
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        jedis.flushDB();
        Map<String, String> map = new HashMap<>();
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key4", "value4");
        // 添加名称为 hash（key）的hash元素
        jedis.hmset("hash", map);
        // 向名称为 hash 的 hash 中添加 key 为 key5，value 为 value5 元素
        jedis.hset("hash", "key5", "value5");
        System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash")); // return Map<String,String>

        System.out.println("散列hash的所有键为：" + jedis.hkeys("hash")); // returnSet<String>
        System.out.println("散列hash的所有值为：" + jedis.hvals("hash")); // returnList<String>
        System.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6：" + jedis.hincrBy("hash", "key6", 6));
        System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash"));
        System.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6：" + jedis.hincrBy("hash", "key6", 3));
        System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash"));
        System.out.println("删除一个或者多个键值对：" + jedis.hdel("hash", "key2"));
        System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash"));
        System.out.println("散列hash中键值对的个数：" + jedis.hlen("hash"));
        System.out.println("判断hash中是否存在key2：" + jedis.hexists("hash", "key2"));
        System.out.println("判断hash中是否存在key3：" + jedis.hexists("hash", "key3"));
        System.out.println("获取hash中的值：" + jedis.hmget("hash", "key3"));
        System.out.println("获取hash中的值：" + jedis.hmget("hash", "key3", "key4"));
    }
}
```

### 事务

这里涉及到了 Redis 的三个事务命令，因为 Redis 事务的内容在后面，所以可以先停下来，去学习 Redis 事务再来看，或者先看这个，再看事务，理解可能更佳！

```java
public class TestMulti {
    public static void main(String[] args) {
        // 创建客户端连接服务端，redis 服务端需要被开启
        Jedis jedis = new Jedis("127.0.0.1", 6379);
        jedis.flushDB();
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("hello", "world");
        jsonObject.put("name", "java");
        
        // 开启事务
        Transaction multi = jedis.multi();
        String result = jsonObject.toJSONString();
        try {
            // 向 redis 存入一条数据
            multi.set("json", result);
            // 再存入一条数据
            multi.set("json2", result);
            // 这里引发了异常，用 0 作为被除数
            int i = 100 / 0;
            // 如果没有引发异常，执行进入队列的命令
            multi.exec();
        } catch (Exception e) {
            e.printStackTrace();
            // 如果出现异常，回滚
            multi.discard();
        } finally {
            System.out.println(jedis.get("json"));
            System.out.println(jedis.get("json2"));
            // 最终关闭客户端
            jedis.close();
        }
    }
}
```

### 随机验证码案例

```java
public class RedisCode {

    private static Jedis jedis = new Jedis("192.168.199.27",6379);
    private final static String phone = "13377492843";
    
    public static void main(String[] args) {
        String code = getCode(phone);
        verifyCode(phone,"14175");
    }
    
    // 1. 输入手机号，随机生成 6 位数字验证码，2 分钟有效，存入redis
    public static String getCode(String phone){
        Random random = new Random();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 6; i++) {
            int code = random.nextInt(10);
            sb.append(code);
        }
        jedis.setex("phone:" + phone + ":code", 120, sb.toString());
        jedis.setex("phone:" + phone + ":count", 120, "0");
        return sb.toString();
        
    }
    
    // 2. 输入验证码，去 Redis 获取进行比对，返回结果
    public static void verifyCode(String phone,String code){
        // 获取 code
        String phoneCode = jedis.get("phone:" + phone + ":code");
        String count = jedis.get("phone:" + phone + ":count");
        // 比较验证次数
        if(Integer.parseInt(count) > 2){
            System.out.println("验证次数超过三次");
            return;
        }
        // 比较验证码
        if(!phoneCode.equals(code)){
            System.out.println("验证失败");
            jedis.incr("phone:" + phone + ":count");
        }else {
            System.out.println("验证成功");
            // 可以立即让验证码和次数过期，即删除
            jedis.unlink("phone:" + phone + ":code","phone:" + phone + ":count");
        }
        jedis.close();
    }       
}
```

## SpringBoot整合

在 Spring Boot 中一般使用 RedisTemplate 提供的方法来操作 Redis。那么使用 Spring Boot 整合 Redis 需要如下步骤：

- JedisPoolConfig：这个是配置连接池

- RedisConnectionFactory：这个是配置连接信息，这里的 RedisConnectionFactory 是一个接口，我们需要使用它的实现类，在 Spring Data Redis 方案中提供了以下四种工厂模型：

    - JredisConnectionFactory

    - JedisConnectionFactory

    - LettuceConnectionFactory

    - SrpConnectionFactory


- RedisTemplate 基本操作

### 基础使用

- 创建 Spring Boot 项目

- 导入依赖

    ```xml
    <!-- redis   -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    <!-- spring 2.X 集成 redis 所需 common-pool2-->
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
        <version>2.6.0</version>
    </dependency>
    ```

说明：在 Spring Boot 2.x 之后，原来使用的 jedis 被替换成 lettuce

- 配置文件

    我这里提供的是 properties 配置文件，如果你是 yml 配置文件，只是格式不一样，代码还是一样的

    ```properties
    # Redis 服务器地址
    spring.redis.host=192.168.140.136
    
    # Redis 服务器连接端口
    spring.redis.port=6379
    
    # Redis 数据库索引（默认为 0）
    spring.redis.database= 0
    
    # 连接超时时间（毫秒）
    spring.redis.timeout=1800000
    
    # 连接池最大连接数（使用负值表示没有限制）
    spring.redis.lettuce.pool.max-active=20
    
    # 最大阻塞等待时间(负数表示没限制)
    spring.redis.lettuce.pool.max-wait=-1
    
    # 连接池中的最大空闲连接
    spring.redis.lettuce.pool.max-idle=5
    
    # 连接池中的最小空闲连接
    spring.redis.lettuce.pool.min-idle=0
    ```

- 测试类中测试

    ```java
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Test
    void contextLoads() {
        redisTemplate.opsForValue().set("myKey", "myValue");
        System.out.println(redisTemplate.opsForValue().get("myKey"));
    }
    ```

### Redis配置类

分析 RedisAutoConfiguration 自动配置类源码：

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })
public class RedisAutoConfiguration {

   @Bean
   @ConditionalOnMissingBean(name = "redisTemplate")
   @ConditionalOnSingleCandidate(RedisConnectionFactory.class)
   public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
      RedisTemplate<Object, Object> template = new RedisTemplate<>();
      template.setConnectionFactory(redisConnectionFactory);
      return template;
   }

   @Bean
   @ConditionalOnMissingBean
   @ConditionalOnSingleCandidate(RedisConnectionFactory.class)
   public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
      StringRedisTemplate template = new StringRedisTemplate();
      template.setConnectionFactory(redisConnectionFactory);
      return template;
   }

}
```

通过源码可以看出，Spring Boot 自动帮我们在容器中生成了一个 RedisTemplate 和一个 StringRedisTemplate。

但是，这个 RedisTemplate 的泛型是 `<Object,Object>`，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为 `<String,Object>` 形式的 RedisTemplate。

并且，这个 RedisTemplate 没有设置数据存在 Redis 时，key-value 的序列化方式。

看到这个 @ConditionalOnMissingBean 注解后，就知道如果 Spring 容器中有了 RedisTemplate 对象了，这个自动配置的 RedisTemplate 不会实例化。因此我们可以直接自己写个配置类，配置 RedisTemplate。

用这个配置我们不可以存储对象，否则会报 SerializationException，大家可自己试试

- 既然自动配置不好用，就重新配置一个 RedisTemplate

搭配 Spring Cache 使用的配置类

```java
@EnableCaching
@Configuration
public class RedisConfig extends CachingConfigurerSupport {
   
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        template.setConnectionFactory(factory);
        // key 序列化方式
        template.setKeySerializer(redisSerializer);
        // value 序列化
        template.setValueSerializer(jackson2JsonRedisSerializer);
        // value hashmap 序列化
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new
                Jackson2JsonRedisSerializer(Object.class);
        // 解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        // 配置序列化（解决乱码的问题）,过期时间 600 秒
        RedisCacheConfiguration config =
                RedisCacheConfiguration.defaultCacheConfig()
                        .entryTtl(Duration.ofSeconds(600))
                        .serializeKeysWith(RedisSerializationContext.SerializationPair.
                                fromSerializer(redisSerializer))
                        .serializeValuesWith(RedisSerializationContext.SerializationPair
                                .fromSerializer(jackson2JsonRedisSerializer))
                        .disableCachingNullValues();
        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
        return cacheManager;
    }
}
```

原生 Spring Boot Redis 配置类

```java
@AutoConfiguration
@ConditionalOnClass(RedisAutoConfiguration.class)
public class RedisTemplateConfig {

    private final RedisConnectionFactory redisConnectionFactory;

    public RedisTemplateConfig(RedisConnectionFactory redisConnectionFactory) {
        this.redisConnectionFactory = redisConnectionFactory;
    }

    @Bean
    public RedisTemplate<String, String> redisTemplateString() {
        return initRedisTemplate(new StringRedisTemplate());
    }

    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        return initRedisTemplate(new RedisTemplate<>());
    }
    
    public <T> RedisTemplate<String, T> initRedisTemplate(RedisTemplate<String, T> redisTemplate) {
        
        redisTemplate.setConnectionFactory(redisConnectionFactory);

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);
        
        // 解决 Redis 无法存入 LocalDateTime 等 JDK8 的时间类
        JavaTimeModule javaTimeModule = new JavaTimeModule();
        /*
         * 新增 LocalDateTime 序列化、反序列化规则
         */
        javaTimeModule
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DatePatternPlus.NORM_DATETIME_FORMATTER)) // yyyy-MM-dd HH:mm:ss
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ISO_LOCAL_TIME)) // HH:mm:ss
                .addSerializer(Instant.class, InstantSerializer.INSTANCE) // Instant 类型序列化
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DatePatternPlus.NORM_DATETIME_FORMATTER)) // yyyy-MM-dd HH:mm:ss
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ISO_LOCAL_DATE)) // yyyy-MM-dd
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ISO_LOCAL_TIME)) // HH:mm:ss
                .addDeserializer(Instant.class, InstantDeserializer.INSTANT);// Instant 反序列化

        objectMapper.registerModules(javaTimeModule);

        // 使用 Jackson2JsonRedisSerialize 替换默认序列化
        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(objectMapper, Object.class);

        /*
         * 设置 value 的序列化规则和 key 的序列化规则
         * RedisTemplate 默认序列化使用的 jdkSerializable, 存储到 Redis 会变成二进制字节码，有风险！
         * 所以官网建议转成其他序列化
         */
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.afterPropertiesSet();

        return redisTemplate;
    }
    
}
```



创建 User 对象，name 和 age

测试存对象

```java
@SpringBootTest
public class RedisTest {

    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    void test() {
        User user = new User("kele",3);
        redisTemplate.opsForValue().set("user",user);
        System.out.println(redisTemplate.opsForValue().get("user"));

    }
}
```

### Redis工具类

使用 RedisTemplate 需要频繁调用 `.opForxxx` 然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共 API 抽取出来封装成为一个工具类，然后直接使用工具类来间接操作 Redis，不但效率高并且易用。

代码很长，我稍微隐藏

<code-group>
  <code-block title="常用工具类" active>

  ```java
  @Component
  public final class RedisUtil {
  	
  	@Autowired
  	private RedisTemplate<String, Object> redisTemplate;
  
  	// =============================common============================
  	/**
  	 * 指定缓存失效时间
  	 * @param key 键
  	 * @param time 时间(秒)
  	 * @return
  	 */
  	public boolean expire(String key, long time) {
  		try {
  			if (time > 0) {
  				redisTemplate.expire(key, time, TimeUnit.SECONDS);
  			}
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 根据key 获取过期时间
  	 * @param key 键 不能为null
  	 * @return 时间(秒) 返回0代表为永久有效
  	 */
  	public long getExpire(String key) {
  		return redisTemplate.getExpire(key, TimeUnit.SECONDS);
  	}
  
  	/**
  	 * 判断key是否存在
  	 * @param key 键
  	 * @return true 存在 false不存在
  	 */
  	public boolean hasKey(String key) {
  		try {
  			return redisTemplate.hasKey(key);
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 删除缓存
  	 * @param key 可以传一个值 或多个
  	 */
  	@SuppressWarnings("unchecked")
  	public void del(String... key) {
  		if (key != null && key.length > 0) {
  			if (key.length == 1) {
  				redisTemplate.delete(key[0]);
  			} else {
  				redisTemplate.delete(CollectionUtils.arrayToList(key));
  			}
  		}
  	}
  
  	// ============================String=============================
  	/**
  	 * 普通缓存获取
  	 * @param key 键
  	 * @return 值
  	 */
  	public Object get(String key) {
  		return key == null ? null : redisTemplate.opsForValue().get(key);
  	}
  
  	/**
  	 * 普通缓存放入
  	 * @param key 键
  	 * @param value 值
  	 * @return true成功 false失败
  	 */
  	public boolean set(String key, Object value) {
  		try {
  			redisTemplate.opsForValue().set(key, value);
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  
  	}
  
  	/**
  	 * 普通缓存放入并设置时间
  	 * @param key 键
  	 * @param value 值
  	 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期
  	 * @return true成功 false 失败
  	 */
  	public boolean set(String key, Object value, long time) {
  		try {
  			if (time > 0) {
  				redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
  			} else {
  				set(key, value);
  			}
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 递增
  	 * @param key 键
  	 * @param delta 要增加几(大于0)
  	 * @return
  	 */
  	public long incr(String key, long delta) {
  		if (delta < 0) {
  			throw new RuntimeException("递增因子必须大于0");
  		}
  		return redisTemplate.opsForValue().increment(key, delta);
  	}
  
  	/**
  	 * 递减
  	 * @param key 键
  	 * @param delta 要减少几(小于0)
  	 * @return
  	 */
  	public long decr(String key, long delta) {
  		if (delta < 0) {
  			throw new RuntimeException("递减因子必须大于0");
  		}
  		return redisTemplate.opsForValue().increment(key, -delta);
  	}
  
  	// ================================Map=================================
  	/**
  	 * HashGet
  	 * @param key 键 不能为null
  	 * @param item 项 不能为null
  	 * @return 值
  	 */
  	public Object hget(String key, String item) {
  		return redisTemplate.opsForHash().get(key, item);
  	}
  
  	/**
  	 * 获取hashKey对应的所有键值
  	 * @param key 键
  	 * @return 对应的多个键值
  	 */
  	public Map<Object, Object> hmget(String key) {
  		return redisTemplate.opsForHash().entries(key);
  	}
  
  	/**
  	 * HashSet
  	 * @param key 键
  	 * @param map 对应多个键值
  	 * @return true 成功 false 失败
  	 */
  	public boolean hmset(String key, Map<String, Object> map) {
  		try {
  			redisTemplate.opsForHash().putAll(key, map);
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * HashSet 并设置时间
  	 * @param key 键
  	 * @param map 对应多个键值
  	 * @param time 时间(秒)
  	 * @return true成功 false失败
  	 */
  	public boolean hmset(String key, Map<String, Object> map, long time) {
  		try {
  			redisTemplate.opsForHash().putAll(key, map);
  			if (time > 0) {
  				expire(key, time);
  			}
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 向一张hash表中放入数据,如果不存在将创建
  	 * @param key 键
  	 * @param item 项
  	 * @param value 值
  	 * @return true 成功 false失败
  	 */
  	public boolean hset(String key, String item, Object value) {
  		try {
  			redisTemplate.opsForHash().put(key, item, value);
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 向一张hash表中放入数据,如果不存在将创建
  	 * @param key 键
  	 * @param item 项
  	 * @param value 值
  	 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间
  	 * @return true 成功 false失败
  	 */
  	public boolean hset(String key, String item, Object value, long time) {
  		try {
  			redisTemplate.opsForHash().put(key, item, value);
  			if (time > 0) {
  				expire(key, time);
  			}
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 删除hash表中的值
  	 * @param key 键 不能为null
  	 * @param item 项 可以使多个 不能为null
  	 */
  	public void hdel(String key, Object... item) {
  		redisTemplate.opsForHash().delete(key, item);
  	}
  
  	/**
  	 * 判断hash表中是否有该项的值
  	 * @param key 键 不能为null
  	 * @param item 项 不能为null
  	 * @return true 存在 false不存在
  	 */
  	public boolean hHasKey(String key, String item) {
  		return redisTemplate.opsForHash().hasKey(key, item);
  	}
  
  	/**
  	 * hash递增 如果不存在,就会创建一个 并把新增后的值返回
  	 * @param key 键
  	 * @param item 项
  	 * @param by 要增加几(大于0)
  	 * @return
  	 */
  	public double hincr(String key, String item, double by) {
  		return redisTemplate.opsForHash().increment(key, item, by);
  	}
  
  	/**
  	 * hash递减
  	 * @param key 键
  	 * @param item 项
  	 * @param by 要减少记(小于0)
  	 * @return
  	 */
  	public double hdecr(String key, String item, double by) {
  		return redisTemplate.opsForHash().increment(key, item, -by);
  	}
  
  	// ============================set=============================
  	/**
  	 * 根据key获取Set中的所有值
  	 * @param key 键
  	 * @return
  	 */
  	public Set<Object> sGet(String key) {
  		try {
  			return redisTemplate.opsForSet().members(key);
  		} catch (Exception e) {
  			e.printStackTrace();
  			return null;
  		}
  	}
  
  	/**
  	 * 根据value从一个set中查询,是否存在
  	 * @param key 键
  	 * @param value 值
  	 * @return true 存在 false不存在
  	 */
  	public boolean sHasKey(String key, Object value) {
  		try {
  			return redisTemplate.opsForSet().isMember(key, value);
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 将数据放入set缓存
  	 * @param key 键
  	 * @param values 值 可以是多个
  	 * @return 成功个数
  	 */
  	public long sSet(String key, Object... values) {
  		try {
  			return redisTemplate.opsForSet().add(key, values);
  		} catch (Exception e) {
  			e.printStackTrace();
  			return 0;
  		}
  	}
  
  	/**
  	 * 将set数据放入缓存
  	 * @param key 键
  	 * @param time 时间(秒)
  	 * @param values 值 可以是多个
  	 * @return 成功个数
  	 */
  	public long sSetAndTime(String key, long time, Object... values) {
  		try {
  			Long count = redisTemplate.opsForSet().add(key, values);
  			if (time > 0)
  				expire(key, time);
  			return count;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return 0;
  		}
  	}
  
  	/**
  	 * 获取set缓存的长度
  	 * @param key 键
  	 * @return
  	 */
  	public long sGetSetSize(String key) {
  		try {
  			return redisTemplate.opsForSet().size(key);
  		} catch (Exception e) {
  			e.printStackTrace();
  			return 0;
  		}
  	}
  
  	/**
  	 * 移除值为value的
  	 * @param key 键
  	 * @param values 值 可以是多个
  	 * @return 移除的个数
  	 */
  	public long setRemove(String key, Object... values) {
  		try {
  			Long count = redisTemplate.opsForSet().remove(key, values);
  			return count;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return 0;
  		}
  	}
  	// ===============================list=================================
  
  	/**
  	 * 获取list缓存的内容
  	 * @param key 键
  	 * @param start 开始
  	 * @param end 结束 0 到 -1代表所有值
  	 * @return
  	 */
  	public List<Object> lGet(String key, long start, long end) {
  		try {
  			return redisTemplate.opsForList().range(key, start, end);
  		} catch (Exception e) {
  			e.printStackTrace();
  			return null;
  		}
  	}
  
  	/**
  	 * 获取list缓存的长度
  	 * @param key 键
  	 * @return
  	 */
  	public long lGetListSize(String key) {
  		try {
  			return redisTemplate.opsForList().size(key);
  		} catch (Exception e) {
  			e.printStackTrace();
  			return 0;
  		}
  	}
  
  	/**
  	 * 通过索引 获取list中的值
  	 * @param key 键
  	 * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推
  	 * @return
  	 */
  	public Object lGetIndex(String key, long index) {
  		try {
  			return redisTemplate.opsForList().index(key, index);
  		} catch (Exception e) {
  			e.printStackTrace();
  			return null;
  		}
  	}
  
  	/**
  	 * 将list放入缓存
  	 * @param key 键
  	 * @param value 值
  	 * @param time 时间(秒)
  	 * @return
  	 */
  	public boolean lSet(String key, Object value) {
  		try {
  			redisTemplate.opsForList().rightPush(key, value);
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 将list放入缓存
  	 * @param key 键
  	 * @param value 值
  	 * @param time 时间(秒)
  	 * @return
  	 */
  	public boolean lSet(String key, Object value, long time) {
  		try {
  			redisTemplate.opsForList().rightPush(key, value);
  			if (time > 0)
  				expire(key, time);
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 将list放入缓存
  	 * @param key 键
  	 * @param value 值
  	 * @param time 时间(秒)
  	 * @return
  	 */
  	public boolean lSet(String key, List<Object> value) {
  		try {
  			redisTemplate.opsForList().rightPushAll(key, value);
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 将list放入缓存
  	 * 
  	 * @param key 键
  	 * @param value 值
  	 * @param time 时间(秒)
  	 * @return
  	 */
  	public boolean lSet(String key, List<Object> value, long time) {
  		try {
  			redisTemplate.opsForList().rightPushAll(key, value);
  			if (time > 0)
  				expire(key, time);
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 根据索引修改list中的某条数据
  	 * @param key 键
  	 * @param index 索引
  	 * @param value 值
  	 * @return
  	 */
  	public boolean lUpdateIndex(String key, long index, Object value) {
  		try {
  			redisTemplate.opsForList().set(key, index, value);
  			return true;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return false;
  		}
  	}
  
  	/**
  	 * 移除N个值为value
  	 * @param key 键
  	 * @param count 移除多少个
  	 * @param value 值
  	 * @return 移除的个数
  	 */
  	public long lRemove(String key, long count, Object value) {
  		try {
  			Long remove = redisTemplate.opsForList().remove(key, count, value);
  			return remove;
  		} catch (Exception e) {
  			e.printStackTrace();
  			return 0;
  		}
  	}
  }
  ```
  </code-block>

  <code-block title="完整工具类：">
  ```java
  public class RedisUtil {
      private StringRedisTemplate redisTemplate;
  
      public void setRedisTemplate(StringRedisTemplate redisTemplate) {
          this.redisTemplate = redisTemplate;
      }
  
      public StringRedisTemplate getRedisTemplate() {
          return this.redisTemplate;
      }
  
      /** -------------------key相关操作--------------------- */
  
      /**
       * 删除key
       * 
       * @param key
       */
      public void delete(String key) {
          redisTemplate.delete(key);
      }
  
      /**
       * 批量删除key
       * 
       * @param keys
       */
      public void delete(Collection<String> keys) {
          redisTemplate.delete(keys);
      }
  
      /**
       * 序列化key
       * 
       * @param key
       * @return
       */
      public byte[] dump(String key) {
          return redisTemplate.dump(key);
      }
  
      /**
       * 是否存在key
       * 
       * @param key
       * @return
       */
      public Boolean hasKey(String key) {
          return redisTemplate.hasKey(key);
      }
  
      /**
       * 设置过期时间
       * 
       * @param key
       * @param timeout
       * @param unit
       * @return
       */
      public Boolean expire(String key, long timeout, TimeUnit unit) {
          return redisTemplate.expire(key, timeout, unit);
      }
  
      /**
       * 设置过期时间
       * 
       * @param key
       * @param date
       * @return
       */
      public Boolean expireAt(String key, Date date) {
          return redisTemplate.expireAt(key, date);
      }
  
      /**
       * 查找匹配的key
       * 
       * @param pattern
       * @return
       */
      public Set<String> keys(String pattern) {
          return redisTemplate.keys(pattern);
      }
  
      /**
       * 将当前数据库的 key 移动到给定的数据库 db 当中
       * 
       * @param key
       * @param dbIndex
       * @return
       */
      public Boolean move(String key, int dbIndex) {
          return redisTemplate.move(key, dbIndex);
      }
  
      /**
       * 移除 key 的过期时间，key 将持久保持
       * 
       * @param key
       * @return
       */
      public Boolean persist(String key) {
          return redisTemplate.persist(key);
      }
  
      /**
       * 返回 key 的剩余的过期时间
       * 
       * @param key
       * @param unit
       * @return
       */
      public Long getExpire(String key, TimeUnit unit) {
          return redisTemplate.getExpire(key, unit);
      }
  
      /**
       * 返回 key 的剩余的过期时间
       * 
       * @param key
       * @return
       */
      public Long getExpire(String key) {
          return redisTemplate.getExpire(key);
      }
  
      /**
       * 从当前数据库中随机返回一个 key
       * 
       * @return
       */
      public String randomKey() {
          return redisTemplate.randomKey();
      }
  
      /**
       * 修改 key 的名称
       * 
       * @param oldKey
       * @param newKey
       */
      public void rename(String oldKey, String newKey) {
          redisTemplate.rename(oldKey, newKey);
      }
  
      /**
       * 仅当 newkey 不存在时，将 oldKey 改名为 newkey
       * 
       * @param oldKey
       * @param newKey
       * @return
       */
      public Boolean renameIfAbsent(String oldKey, String newKey) {
          return redisTemplate.renameIfAbsent(oldKey, newKey);
      }
  
      /**
       * 返回 key 所储存的值的类型
       * 
       * @param key
       * @return
       */
      public DataType type(String key) {
          return redisTemplate.type(key);
      }
  
      /** -------------------string相关操作--------------------- */
  
      /**
       * 设置指定 key 的值
       * @param key
       * @param value
       */
      public void set(String key, String value) {
          redisTemplate.opsForValue().set(key, value);
      }
  
      /**
       * 获取指定 key 的值
       * @param key
       * @return
       */
      public String get(String key) {
          return redisTemplate.opsForValue().get(key);
      }
  
      /**
       * 返回 key 中字符串值的子字符
       * @param key
       * @param start
       * @param end
       * @return
       */
      public String getRange(String key, long start, long end) {
          return redisTemplate.opsForValue().get(key, start, end);
      }
  
      /**
       * 将给定 key 的值设为 value ，并返回 key 的旧值(old value)
       * 
       * @param key
       * @param value
       * @return
       */
      public String getAndSet(String key, String value) {
          return redisTemplate.opsForValue().getAndSet(key, value);
      }
  
      /**
       * 对 key 所储存的字符串值，获取指定偏移量上的位(bit)
       * 
       * @param key
       * @param offset
       * @return
       */
      public Boolean getBit(String key, long offset) {
          return redisTemplate.opsForValue().getBit(key, offset);
      }
  
      /**
       * 批量获取
       * 
       * @param keys
       * @return
       */
      public List<String> multiGet(Collection<String> keys) {
          return redisTemplate.opsForValue().multiGet(keys);
      }
  
      /**
       * 设置ASCII码, 字符串'a'的ASCII码是97, 转为二进制是'01100001', 此方法是将二进制第offset位值变为value
       * 
       * @param key 位置
       * @param value
       *            值,true为1, false为0
       * @return
       */
      public boolean setBit(String key, long offset, boolean value) {
          return redisTemplate.opsForValue().setBit(key, offset, value);
      }
  
      /**
       * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout
       * 
       * @param key
       * @param value
       * @param timeout
       *            过期时间
       * @param unit
       *            时间单位, 天:TimeUnit.DAYS 小时:TimeUnit.HOURS 分钟:TimeUnit.MINUTES
       *            秒:TimeUnit.SECONDS 毫秒:TimeUnit.MILLISECONDS
       */
      public void setEx(String key, String value, long timeout, TimeUnit unit) {
          redisTemplate.opsForValue().set(key, value, timeout, unit);
      }
  
      /**
       * 只有在 key 不存在时设置 key 的值
       * 
       * @param key
       * @param value
       * @return 之前已经存在返回false,不存在返回true
       */
      public boolean setIfAbsent(String key, String value) {
          return redisTemplate.opsForValue().setIfAbsent(key, value);
      }
  
      /**
       * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始
       * 
       * @param key
       * @param value
       * @param offset
       *            从指定位置开始覆写
       */
      public void setRange(String key, String value, long offset) {
          redisTemplate.opsForValue().set(key, value, offset);
      }
  
      /**
       * 获取字符串的长度
       * 
       * @param key
       * @return
       */
      public Long size(String key) {
          return redisTemplate.opsForValue().size(key);
      }
  
      /**
       * 批量添加
       * 
       * @param maps
       */
      public void multiSet(Map<String, String> maps) {
          redisTemplate.opsForValue().multiSet(maps);
      }
  
      /**
       * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在
       * 
       * @param maps
       * @return 之前已经存在返回false,不存在返回true
       */
      public boolean multiSetIfAbsent(Map<String, String> maps) {
          return redisTemplate.opsForValue().multiSetIfAbsent(maps);
      }
  
      /**
       * 增加(自增长), 负数则为自减
       * 
       * @param key
       * @return
       */
      public Long incrBy(String key, long increment) {
          return redisTemplate.opsForValue().increment(key, increment);
      }
  
      /**
       * 
       * @param key
       * @return
       */
      public Double incrByFloat(String key, double increment) {
          return redisTemplate.opsForValue().increment(key, increment);
      }
  
      /**
       * 追加到末尾
       * 
       * @param key
       * @param value
       * @return
       */
      public Integer append(String key, String value) {
          return redisTemplate.opsForValue().append(key, value);
      }
  
      /** -------------------hash相关操作------------------------- */
  
      /**
       * 获取存储在哈希表中指定字段的值
       * 
       * @param key
       * @param field
       * @return
       */
      public Object hGet(String key, String field) {
          return redisTemplate.opsForHash().get(key, field);
      }
  
      /**
       * 获取所有给定字段的值
       * 
       * @param key
       * @return
       */
      public Map<Object, Object> hGetAll(String key) {
          return redisTemplate.opsForHash().entries(key);
      }
  
      /**
       * 获取所有给定字段的值
       * 
       * @param key
       * @param fields
       * @return
       */
      public List<Object> hMultiGet(String key, Collection<Object> fields) {
          return redisTemplate.opsForHash().multiGet(key, fields);
      }
  
      public void hPut(String key, String hashKey, String value) {
          redisTemplate.opsForHash().put(key, hashKey, value);
      }
  
      public void hPutAll(String key, Map<String, String> maps) {
          redisTemplate.opsForHash().putAll(key, maps);
      }
  
      /**
       * 仅当hashKey不存在时才设置
       * 
       * @param key
       * @param hashKey
       * @param value
       * @return
       */
      public Boolean hPutIfAbsent(String key, String hashKey, String value) {
          return redisTemplate.opsForHash().putIfAbsent(key, hashKey, value);
      }
  
      /**
       * 删除一个或多个哈希表字段
       * 
       * @param key
       * @param fields
       * @return
       */
      public Long hDelete(String key, Object... fields) {
          return redisTemplate.opsForHash().delete(key, fields);
      }
  
      /**
       * 查看哈希表 key 中，指定的字段是否存在
       * 
       * @param key
       * @param field
       * @return
       */
      public boolean hExists(String key, String field) {
          return redisTemplate.opsForHash().hasKey(key, field);
      }
  
      /**
       * 为哈希表 key 中的指定字段的整数值加上增量 increment
       * 
       * @param key
       * @param field
       * @param increment
       * @return
       */
      public Long hIncrBy(String key, Object field, long increment) {
          return redisTemplate.opsForHash().increment(key, field, increment);
      }
  
      /**
       * 为哈希表 key 中的指定字段的整数值加上增量 increment
       * 
       * @param key
       * @param field
       * @param delta
       * @return
       */
      public Double hIncrByFloat(String key, Object field, double delta) {
          return redisTemplate.opsForHash().increment(key, field, delta);
      }
  
      /**
       * 获取所有哈希表中的字段
       * 
       * @param key
       * @return
       */
      public Set<Object> hKeys(String key) {
          return redisTemplate.opsForHash().keys(key);
      }
  
      /**
       * 获取哈希表中字段的数量
       * 
       * @param key
       * @return
       */
      public Long hSize(String key) {
          return redisTemplate.opsForHash().size(key);
      }
  
      /**
       * 获取哈希表中所有值
       * 
       * @param key
       * @return
       */
      public List<Object> hValues(String key) {
          return redisTemplate.opsForHash().values(key);
      }
  
      /**
       * 迭代哈希表中的键值对
       * 
       * @param key
       * @param options
       * @return
       */
      public Cursor<Entry<Object, Object>> hScan(String key, ScanOptions options) {
          return redisTemplate.opsForHash().scan(key, options);
      }
  
      /** ------------------------list相关操作---------------------------- */
  
      /**
       * 通过索引获取列表中的元素
       * 
       * @param key
       * @param index
       * @return
       */
      public String lIndex(String key, long index) {
          return redisTemplate.opsForList().index(key, index);
      }
  
      /**
       * 获取列表指定范围内的元素
       * 
       * @param key
       * @param start
       *            开始位置, 0是开始位置
       * @param end
       *            结束位置, -1返回所有
       * @return
       */
      public List<String> lRange(String key, long start, long end) {
          return redisTemplate.opsForList().range(key, start, end);
      }
  
      /**
       * 存储在list头部
       * 
       * @param key
       * @param value
       * @return
       */
      public Long lLeftPush(String key, String value) {
          return redisTemplate.opsForList().leftPush(key, value);
      }
  
      /**
       * 
       * @param key
       * @param value
       * @return
       */
      public Long lLeftPushAll(String key, String... value) {
          return redisTemplate.opsForList().leftPushAll(key, value);
      }
  
      /**
       * 
       * @param key
       * @param value
       * @return
       */
      public Long lLeftPushAll(String key, Collection<String> value) {
          return redisTemplate.opsForList().leftPushAll(key, value);
      }
  
      /**
       * 当list存在的时候才加入
       * 
       * @param key
       * @param value
       * @return
       */
      public Long lLeftPushIfPresent(String key, String value) {
          return redisTemplate.opsForList().leftPushIfPresent(key, value);
      }
  
      /**
       * 如果pivot存在,再pivot前面添加
       * 
       * @param key
       * @param pivot
       * @param value
       * @return
       */
      public Long lLeftPush(String key, String pivot, String value) {
          return redisTemplate.opsForList().leftPush(key, pivot, value);
      }
  
      /**
       * 
       * @param key
       * @param value
       * @return
       */
      public Long lRightPush(String key, String value) {
          return redisTemplate.opsForList().rightPush(key, value);
      }
  
      /**
       * 
       * @param key
       * @param value
       * @return
       */
      public Long lRightPushAll(String key, String... value) {
          return redisTemplate.opsForList().rightPushAll(key, value);
      }
  
      /**
       * 
       * @param key
       * @param value
       * @return
       */
      public Long lRightPushAll(String key, Collection<String> value) {
          return redisTemplate.opsForList().rightPushAll(key, value);
      }
  
      /**
       * 为已存在的列表添加值
       * 
       * @param key
       * @param value
       * @return
       */
      public Long lRightPushIfPresent(String key, String value) {
          return redisTemplate.opsForList().rightPushIfPresent(key, value);
      }
  
      /**
       * 在pivot元素的右边添加值
       * 
       * @param key
       * @param pivot
       * @param value
       * @return
       */
      public Long lRightPush(String key, String pivot, String value) {
          return redisTemplate.opsForList().rightPush(key, pivot, value);
      }
  
      /**
       * 通过索引设置列表元素的值
       * 
       * @param key
       * @param index
       *            位置
       * @param value
       */
      public void lSet(String key, long index, String value) {
          redisTemplate.opsForList().set(key, index, value);
      }
  
      /**
       * 移出并获取列表的第一个元素
       * 
       * @param key
       * @return 删除的元素
       */
      public String lLeftPop(String key) {
          return redisTemplate.opsForList().leftPop(key);
      }
  
      /**
       * 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止
       * 
       * @param key
       * @param timeout
       *            等待时间
       * @param unit
       *            时间单位
       * @return
       */
      public String lBLeftPop(String key, long timeout, TimeUnit unit) {
          return redisTemplate.opsForList().leftPop(key, timeout, unit);
      }
  
      /**
       * 移除并获取列表最后一个元素
       * 
       * @param key
       * @return 删除的元素
       */
      public String lRightPop(String key) {
          return redisTemplate.opsForList().rightPop(key);
      }
  
      /**
       * 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止
       * 
       * @param key
       * @param timeout
       *            等待时间
       * @param unit
       *            时间单位
       * @return
       */
      public String lBRightPop(String key, long timeout, TimeUnit unit) {
          return redisTemplate.opsForList().rightPop(key, timeout, unit);
      }
  
      /**
       * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回
       * 
       * @param sourceKey
       * @param destinationKey
       * @return
       */
      public String lRightPopAndLeftPush(String sourceKey, String destinationKey) {
          return redisTemplate.opsForList().rightPopAndLeftPush(sourceKey,
                                                                destinationKey);
      }
  
      /**
       * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止
       * 
       * @param sourceKey
       * @param destinationKey
       * @param timeout
       * @param unit
       * @return
       */
      public String lBRightPopAndLeftPush(String sourceKey, String destinationKey,
                                          long timeout, TimeUnit unit) {
          return redisTemplate.opsForList().rightPopAndLeftPush(sourceKey,
                                                                destinationKey, timeout, unit);
      }
  
      /**
       * 删除集合中值等于value得元素
       * 
       * @param key
       * @param index
       *            index=0, 删除所有值等于value的元素; index>0, 从头部开始删除第一个值等于value的元素;
       *            index<0, 从尾部开始删除第一个值等于value的元素;
       * @param value
       * @return
       */
      public Long lRemove(String key, long index, String value) {
          return redisTemplate.opsForList().remove(key, index, value);
      }
  
      /**
       * 裁剪list
       * 
       * @param key
       * @param start
       * @param end
       */
      public void lTrim(String key, long start, long end) {
          redisTemplate.opsForList().trim(key, start, end);
      }
  
      /**
       * 获取列表长度
       * 
       * @param key
       * @return
       */
      public Long lLen(String key) {
          return redisTemplate.opsForList().size(key);
      }
  
      /** --------------------set相关操作-------------------------- */
  
      /**
       * set添加元素
       * 
       * @param key
       * @param values
       * @return
       */
      public Long sAdd(String key, String... values) {
          return redisTemplate.opsForSet().add(key, values);
      }
  
      /**
       * set移除元素
       * 
       * @param key
       * @param values
       * @return
       */
      public Long sRemove(String key, Object... values) {
          return redisTemplate.opsForSet().remove(key, values);
      }
  
      /**
       * 移除并返回集合的一个随机元素
       * 
       * @param key
       * @return
       */
      public String sPop(String key) {
          return redisTemplate.opsForSet().pop(key);
      }
  
      /**
       * 将元素value从一个集合移到另一个集合
       * 
       * @param key
       * @param value
       * @param destKey
       * @return
       */
      public Boolean sMove(String key, String value, String destKey) {
          return redisTemplate.opsForSet().move(key, value, destKey);
      }
  
      /**
       * 获取集合的大小
       * 
       * @param key
       * @return
       */
      public Long sSize(String key) {
          return redisTemplate.opsForSet().size(key);
      }
  
      /**
       * 判断集合是否包含value
       * 
       * @param key
       * @param value
       * @return
       */
      public Boolean sIsMember(String key, Object value) {
          return redisTemplate.opsForSet().isMember(key, value);
      }
  
      /**
       * 获取两个集合的交集
       * 
       * @param key
       * @param otherKey
       * @return
       */
      public Set<String> sIntersect(String key, String otherKey) {
          return redisTemplate.opsForSet().intersect(key, otherKey);
      }
  
      /**
       * 获取key集合与多个集合的交集
       * 
       * @param key
       * @param otherKeys
       * @return
       */
      public Set<String> sIntersect(String key, Collection<String> otherKeys) {
          return redisTemplate.opsForSet().intersect(key, otherKeys);
      }
  
      /**
       * key集合与otherKey集合的交集存储到destKey集合中
       * 
       * @param key
       * @param otherKey
       * @param destKey
       * @return
       */
      public Long sIntersectAndStore(String key, String otherKey, String destKey) {
          return redisTemplate.opsForSet().intersectAndStore(key, otherKey,
                                                             destKey);
      }
  
      /**
       * key集合与多个集合的交集存储到destKey集合中
       * 
       * @param key
       * @param otherKeys
       * @param destKey
       * @return
       */
      public Long sIntersectAndStore(String key, Collection<String> otherKeys,
                                     String destKey) {
          return redisTemplate.opsForSet().intersectAndStore(key, otherKeys,
                                                             destKey);
      }
  
      /**
       * 获取两个集合的并集
       * 
       * @param key
       * @param otherKeys
       * @return
       */
      public Set<String> sUnion(String key, String otherKeys) {
          return redisTemplate.opsForSet().union(key, otherKeys);
      }
  
      /**
       * 获取key集合与多个集合的并集
       * 
       * @param key
       * @param otherKeys
       * @return
       */
      public Set<String> sUnion(String key, Collection<String> otherKeys) {
          return redisTemplate.opsForSet().union(key, otherKeys);
      }
  
      /**
       * key集合与otherKey集合的并集存储到destKey中
       * 
       * @param key
       * @param otherKey
       * @param destKey
       * @return
       */
      public Long sUnionAndStore(String key, String otherKey, String destKey) {
          return redisTemplate.opsForSet().unionAndStore(key, otherKey, destKey);
      }
  
      /**
       * key集合与多个集合的并集存储到destKey中
       * 
       * @param key
       * @param otherKeys
       * @param destKey
       * @return
       */
      public Long sUnionAndStore(String key, Collection<String> otherKeys,
                                 String destKey) {
          return redisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey);
      }
  
      /**
       * 获取两个集合的差集
       * 
       * @param key
       * @param otherKey
       * @return
       */
      public Set<String> sDifference(String key, String otherKey) {
          return redisTemplate.opsForSet().difference(key, otherKey);
      }
  
      /**
       * 获取key集合与多个集合的差集
       * 
       * @param key
       * @param otherKeys
       * @return
       */
      public Set<String> sDifference(String key, Collection<String> otherKeys) {
          return redisTemplate.opsForSet().difference(key, otherKeys);
      }
  
      /**
       * key集合与otherKey集合的差集存储到destKey中
       * 
       * @param key
       * @param otherKey
       * @param destKey
       * @return
       */
      public Long sDifference(String key, String otherKey, String destKey) {
          return redisTemplate.opsForSet().differenceAndStore(key, otherKey,
                                                              destKey);
      }
  
      /**
       * key集合与多个集合的差集存储到destKey中
       * 
       * @param key
       * @param otherKeys
       * @param destKey
       * @return
       */
      public Long sDifference(String key, Collection<String> otherKeys,
                              String destKey) {
          return redisTemplate.opsForSet().differenceAndStore(key, otherKeys,
                                                              destKey);
      }
  
      /**
       * 获取集合所有元素
       * 
       * @param key
       * @return
       */
      public Set<String> setMembers(String key) {
          return redisTemplate.opsForSet().members(key);
      }
  
      /**
       * 随机获取集合中的一个元素
       * 
       * @param key
       * @return
       */
      public String sRandomMember(String key) {
          return redisTemplate.opsForSet().randomMember(key);
      }
  
      /**
       * 随机获取集合中count个元素
       * 
       * @param key
       * @param count
       * @return
       */
      public List<String> sRandomMembers(String key, long count) {
          return redisTemplate.opsForSet().randomMembers(key, count);
      }
  
      /**
       * 随机获取集合中count个元素并且去除重复的
       * 
       * @param key
       * @param count
       * @return
       */
      public Set<String> sDistinctRandomMembers(String key, long count) {
          return redisTemplate.opsForSet().distinctRandomMembers(key, count);
      }
  
      /**
       * 
       * @param key
       * @param options
       * @return
       */
      public Cursor<String> sScan(String key, ScanOptions options) {
          return redisTemplate.opsForSet().scan(key, options);
      }
  
      /**------------------zSet相关操作--------------------------------*/
  
      /**
       * 添加元素,有序集合是按照元素的score值由小到大排列
       * 
       * @param key
       * @param value
       * @param score
       * @return
       */
      public Boolean zAdd(String key, String value, double score) {
          return redisTemplate.opsForZSet().add(key, value, score);
      }
  
      /**
       * 
       * @param key
       * @param values
       * @return
       */
      public Long zAdd(String key, Set<TypedTuple<String>> values) {
          return redisTemplate.opsForZSet().add(key, values);
      }
  
      /**
       * 
       * @param key
       * @param values
       * @return
       */
      public Long zRemove(String key, Object... values) {
          return redisTemplate.opsForZSet().remove(key, values);
      }
  
      /**
       * 增加元素的score值，并返回增加后的值
       * 
       * @param key
       * @param value
       * @param delta
       * @return
       */
      public Double zIncrementScore(String key, String value, double delta) {
          return redisTemplate.opsForZSet().incrementScore(key, value, delta);
      }
  
      /**
       * 返回元素在集合的排名,有序集合是按照元素的score值由小到大排列
       * 
       * @param key
       * @param value
       * @return 0表示第一位
       */
      public Long zRank(String key, Object value) {
          return redisTemplate.opsForZSet().rank(key, value);
      }
  
      /**
       * 返回元素在集合的排名,按元素的score值由大到小排列
       * 
       * @param key
       * @param value
       * @return
       */
      public Long zReverseRank(String key, Object value) {
          return redisTemplate.opsForZSet().reverseRank(key, value);
      }
  
      /**
       * 获取集合的元素, 从小到大排序
       * 
       * @param key
       * @param start
       *            开始位置
       * @param end
       *            结束位置, -1查询所有
       * @return
       */
      public Set<String> zRange(String key, long start, long end) {
          return redisTemplate.opsForZSet().range(key, start, end);
      }
  
      /**
       * 获取集合元素, 并且把score值也获取
       * 
       * @param key
       * @param start
       * @param end
       * @return
       */
      public Set<TypedTuple<String>> zRangeWithScores(String key, long start,
                                                      long end) {
          return redisTemplate.opsForZSet().rangeWithScores(key, start, end);
      }
  
      /**
       * 根据Score值查询集合元素
       * 
       * @param key
       * @param min
       *            最小值
       * @param max
       *            最大值
       * @return
       */
      public Set<String> zRangeByScore(String key, double min, double max) {
          return redisTemplate.opsForZSet().rangeByScore(key, min, max);
      }
  
      /**
       * 根据Score值查询集合元素, 从小到大排序
       * 
       * @param key
       * @param min
       *            最小值
       * @param max
       *            最大值
       * @return
       */
      public Set<TypedTuple<String>> zRangeByScoreWithScores(String key,
                                                             double min, double max) {
          return redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max);
      }
  
      /**
       * 
       * @param key
       * @param min
       * @param max
       * @param start
       * @param end
       * @return
       */
      public Set<TypedTuple<String>> zRangeByScoreWithScores(String key,
                                                             double min, double max, long start, long end) {
          return redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max,
                                                                   start, end);
      }
  
      /**
       * 获取集合的元素, 从大到小排序
       * 
       * @param key
       * @param start
       * @param end
       * @return
       */
      public Set<String> zReverseRange(String key, long start, long end) {
          return redisTemplate.opsForZSet().reverseRange(key, start, end);
      }
  
      /**
       * 获取集合的元素, 从大到小排序, 并返回score值
       * 
       * @param key
       * @param start
       * @param end
       * @return
       */
      public Set<TypedTuple<String>> zReverseRangeWithScores(String key,
                                                             long start, long end) {
          return redisTemplate.opsForZSet().reverseRangeWithScores(key, start,
                                                                   end);
      }
  
      /**
       * 根据Score值查询集合元素, 从大到小排序
       * 
       * @param key
       * @param min
       * @param max
       * @return
       */
      public Set<String> zReverseRangeByScore(String key, double min,
                                              double max) {
          return redisTemplate.opsForZSet().reverseRangeByScore(key, min, max);
      }
  
      /**
       * 根据Score值查询集合元素, 从大到小排序
       * 
       * @param key
       * @param min
       * @param max
       * @return
       */
      public Set<TypedTuple<String>> zReverseRangeByScoreWithScores(
          String key, double min, double max) {
          return redisTemplate.opsForZSet().reverseRangeByScoreWithScores(key,
                                                                          min, max);
      }
  
      /**
       * 
       * @param key
       * @param min
       * @param max
       * @param start
       * @param end
       * @return
       */
      public Set<String> zReverseRangeByScore(String key, double min,
                                              double max, long start, long end) {
          return redisTemplate.opsForZSet().reverseRangeByScore(key, min, max,
                                                                start, end);
      }
  
      /**
       * 根据score值获取集合元素数量
       * 
       * @param key
       * @param min
       * @param max
       * @return
       */
      public Long zCount(String key, double min, double max) {
          return redisTemplate.opsForZSet().count(key, min, max);
      }
  
      /**
       * 获取集合大小
       * 
       * @param key
       * @return
       */
      public Long zSize(String key) {
          return redisTemplate.opsForZSet().size(key);
      }
  
      /**
       * 获取集合大小
       * 
       * @param key
       * @return
       */
      public Long zZCard(String key) {
          return redisTemplate.opsForZSet().zCard(key);
      }
  
      /**
       * 获取集合中value元素的score值
       * 
       * @param key
       * @param value
       * @return
       */
      public Double zScore(String key, Object value) {
          return redisTemplate.opsForZSet().score(key, value);
      }
  
      /**
       * 移除指定索引位置的成员
       * 
       * @param key
       * @param start
       * @param end
       * @return
       */
      public Long zRemoveRange(String key, long start, long end) {
          return redisTemplate.opsForZSet().removeRange(key, start, end);
      }
  
      /**
       * 根据指定的score值的范围来移除成员
       * 
       * @param key
       * @param min
       * @param max
       * @return
       */
      public Long zRemoveRangeByScore(String key, double min, double max) {
          return redisTemplate.opsForZSet().removeRangeByScore(key, min, max);
      }
  
      /**
       * 获取key和otherKey的并集并存储在destKey中
       * 
       * @param key
       * @param otherKey
       * @param destKey
       * @return
       */
      public Long zUnionAndStore(String key, String otherKey, String destKey) {
          return redisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey);
      }
  
      /**
       * 
       * @param key
       * @param otherKeys
       * @param destKey
       * @return
       */
      public Long zUnionAndStore(String key, Collection<String> otherKeys,
                                 String destKey) {
          return redisTemplate.opsForZSet()
              .unionAndStore(key, otherKeys, destKey);
      }
  
      /**
       * 交集
       * 
       * @param key
       * @param otherKey
       * @param destKey
       * @return
       */
      public Long zIntersectAndStore(String key, String otherKey,
                                     String destKey) {
          return redisTemplate.opsForZSet().intersectAndStore(key, otherKey,
                                                              destKey);
      }
  
      /**
       * 交集
       * 
       * @param key
       * @param otherKeys
       * @param destKey
       * @return
       */
      public Long zIntersectAndStore(String key, Collection<String> otherKeys,
                                     String destKey) {
          return redisTemplate.opsForZSet().intersectAndStore(key, otherKeys,
                                                              destKey);
      }
  
      /**
       * 
       * @param key
       * @param options
       * @return
       */
      public Cursor<TypedTuple<String>> zScan(String key, ScanOptions options) {
          return redisTemplate.opsForZSet().scan(key, options);
      }
  }
  ```
  </code-block>
</code-group>



工具类参考来源：

`https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html`

`https://www.cnblogs.com/zhzhlong/p/11434284.html`

